Outlaw Resources
================

Outlaw resources address some of the problems of the standard Ruby on Rails route
generating tools. Routes are the means of mapping executable code to HTTP requests,
which make it possible for a Rails app to interface with a web browser. This plugin
allows you to conveniently generate a better, more consistent, more RESTful (or
*less* RESTful, prettier) set of resource routes than what the traditional Rails
methods offer.

Outlaw routes offer perfect back-compatibility, for generating standard Rails routes
alongside Outlaw routes. This allows you to painlessly provide routing services to
existing code, while providing new features for any new code to use. If you choose to
migrate your existing code to entirely Outlaw routes, you'll be able to safely do this
at your own pace, and then eliminate the back-compatibility routes when your code no
longer needs them. If you'd rather keep all your old code exactly as it was, you won't
need to change anything in your `routes.rb` script, or any of your other code at all. The
plugin will cohabitate with the traditional routing mechanisms without conflict. You can
mix and match traditional Rails code and Outlaw Rail code in the same `config/routes.rb`
file, so long as it provides all the routes needed by your Application. Or if you prefer
to gently migrate away from classic routes, such routes can be generated by the Outlaw
routing system alongside (or instead of) any additional Outlaw routes, as you gradually
replace old code with new. If you choose to rewrite part of your routes.rb file, there
are Rake tasks to help you figure out how. See `doc/syntax_tools` for help with that.

Outlaw Resources provide great flexibility in the creation of your routes. You can
conveniently designate individual routes, or classes of routes, to be created, or to
be omitted from creation. You can even ask that the routes not actually be mapped,
and instead be returned as an array of route descriptors, or of lines of Ruby source code
for you to programatically manipulate before mapping them into exactly the live routes
you want.

REST and Rails routing
----------------------

REST (REpresentational State Transfer) is a potentially complex topic, but the basic
idea for a Rails application is that the meaning of a given URL varies according
to the which HTTP verb (GET, POST, PUT, DELETE) was used in the request for that
URL. The client machine may also ask for or offer data in a particular format (HTML,
XML, YAML, etc.), and your Rails app may try to accommodate that aspect of the
request, if it knows how. None of these extra features interfere with the usual
human-and-web-browser use case of your Rails server.

Not all REST features must be supported in your code in order for you to begin
enjoying the benefits. If the world can expect your HTTP interface to behave somewhat
RESTfully, any Internet service can begin using your application in ways that go beyond
human-user web browsing, and both ends can benefit. You can then continually add
support for more complete REST coverage as you build it.

The basic Outlaw routing scheme is compatible with what software agents expect when
communicating with REST-compliant resources. However, the default\* URLs and their "route
names" differ from traditional Rails conventions. Where Rails tends to mix singular and
plural forms of the same word to build the various URL paths and route names, Outlaw
routes only do this when asked (i.e. for Rails compatibility). Outlaw routes favor the
use of only one form of each identifier, so you don't have to manage singulars and plurals
anymore. More to the point, your clients will no longer need to do this. This makes Outlaw
routes more compatible with non-Rails agents, and more consistent for anyone trying to
guess the address of one of your public REST services.

>\* Standard Rails REST routes are fully supported as **"classic"** routes, along with all
the obscure method-call options and nesting functionality you might expect. In addition, you
can also (or instead) generate the new-style **"restful"** routes, which provide a superset
of the classic functionality, but with more sensible names and paths. And if you want more
human-friendly URLs for a user-facing web page, you can choose **"pretty"** routes, which
tend to be slightly more obvious in their meaning for a human reader. Of course you can
combine all of these, to make overlapping functionality for the best features of each.

The Default Routes
------------------

In the config/routes.rb script, this code...

	map.outlaw_resources :blog

...will give you these routes:

	Route name     Sample URL path   GET    POST   PUT    DELETE
	-------------- ----------------- ------ ------ ------ ------
	blog_root      blog              index  create
	blog_index     blog/index        index
	blog_new       blog/new          new
	blog_id        blog/5            show          update destroy
	blog_id_edit   blog/5/edit       edit

These named routes implement REST in a way very similar to classic Rails. The names
of the routes are more consistent, the URLs are less noisy, and there are two ways
to trigger the `index` action, but they deliver all the same functionality as the
routes created by `map.resources`. This Outlaw style of naming REST routes echos
the URL path to which it refers, and is suggestive of the parameters expected by
the helper methods. Imagine a route name's underscores as slashes and `id` segments
as actual ID values, and voila, you see the URL path. It's easy to eliminate
the `_root` segment from the names, but it's there by default to prevent name
collisions with classic Rails routes, and to make dynamic method names such as
`blog_root_path()` or `blog_root_url()` slightly more clear.

Each of the seven standard Rails RESTful actions maps to at least one of these routes.
While routes created by `map.resources` continue to work as before, the `map.outlaw_reources`
routes are easier to memorize and decipher, and don't rely on plural forms of words.
The default Outlaw routes provide two ways to invoke an `index` action: `GET blog` or
`GET blog/index`. The first form is provided so that a client REST agent
can invoke different actions with the same URL by varying the HTTP verb in the expected
fashion. The `index` and the `create` actions are supposed to share the same URL in such
a usage context. The second form may be preferred for user-facing views. For example, if
a user hovers over a link to a list all the blogs, it's slightly less confusing to see
something like, "click to go to example.com/blog/index" in the status bar, rather than,
"click to go to example.com/blog". In any case, either path references the same Ruby code.

RESTful Routes
--------------

In the config/routes.rb script, this code...

	map.outlaw_resources :blog, :provide=>:restful

...will give you these routes:

	Route name     Sample URL path   GET    POST   PUT    DELETE
	-------------- ----------------- ------ ------ ------ ------
	blog_root      blog              index  create
	blog_new       blog/new          new
	blog_id        blog/5            show          update destroy
	blog_id_edit   blog/5/edit       edit

This is the same as the default routes, without the "pretty index" route. This is
functionally equivalent to the standard Rails RESTful routes, but with different
route names and URL paths.

Classic Routes
--------------

In order to continue to support existing Rails code, Outlaw Routes can generate classic
Rails routes alongside the new-style routes. This allows you to begin using the Outlaw
features, without breaking your old code.

For every possible outcome from the `resources` and `resource` methods, there is a
corresponding syntax for the `outlaw_resources` and `outlaw_resource` methods which
will generate a functionally identical set of routes, or a superset of the routes.

Putting this code into your config/routes.rb script...

	map.outlaw_resources :blog, :provide=>:classic, :controller=>:blogs	

...has exactly the same effect as this code...

	map.resources :blogs

...which is to give you these routes:

	Route name     Sample URL path   GET    POST   PUT    DELETE
	-------------- ----------------- ------ ------ ------ ------
	blogs          blogs             index  create
	new_blog       blogs/new         new
	blog           blogs/5           show          update destroy
	edit_blog      blogs/5/edit      edit

Outlaw routes assume an unmodified name ("blog" in this case) for everything except
classic route names and paths. So if we haven't switched to singular controller names
(which is usually fairly painless), we'll want to specify the plural controller name
(as shown). An alternate way to accomplish this would've been the
`:plural_controllers=>true` option.

The above example does nothing new, so let's change it.

This code...

	map.outlaw_resources :blog, :provide=>[:classic,:default], :controller=>:blogs

...maps these routes for us...

	Route name      Sample URL path   GET    POST   PUT    DELETE
	--------------- ----------------- ------ ------ ------ ------
	blogs           blogs             index  create
	new_blog        blogs/new         new
	blog            blogs/5           show          update destroy
	edit_blog       blogs/5/edit      edit
	blog_root       blog              index  create
	blog_index      blog/index        index
	blog_new        blog/new          new
	blog_id         blog/5            show          update destroy
	blog_id_edit    blog/5/edit       edit

This is the same set of routes as if we'd written...

	map.resources :blogs
	map.outlaw_resources :blog, :controller=>:blogs

...but it's usually better to consolidate the two lines into one. Although the
above two-call example works perfectly fine, the one-call equivalent is preferred.
When the two calls are consolidated into a single call, the Outlaw route generator
is able to avoid name collisions, which can occur in certain edge cases.

All of the options and nesting possibilities supported by Rails' traditional `resource`
and `resources` methods are also supported by their Outlaw counterpart. Migration tools
are provided to help translate `resource` or `resources` code into properly-formed
`outlaw_resource` equivalents. Everything that is possible using the traditional
mechanisms is also possible here, but the syntax might be different to accomplish it.
There are tools provided to help translate classic Rails syntax to the Outlaw equivalent.
See `doc/syntax_tools` for help with those tools.

Pretty Routes
-------------

In addition to `classic` and `restful` routes, the third major class of Outlaw routes is
`pretty` routes. Pretty routes can be mapped alongside--or instead of--all the other routes.

This code in config/routes.rb...

	map.outlaw_resources :news, :provide=>:pretty

...gives you these routes...

	Route name         Sample URL path    GET    POST   PUT    DELETE
	------------------ ------------------ ------ ------ ------ ------
	news_index         news/index         index
	news_new           news/new           new
	news_create        news/create               create
	news_id_show       news/228/show      show
	news_id_edit       news/228/edit      edit
	news_id_update     news/228/update                  update
	news_id_destroy    news/228/destroy                        destroy

Here we get sparse routes, where each of the seven standard actions is served
by its own URL and route name. This is the opposite of the REST philosophy, but
the URLs are more obvious and explicitly describe their function.

If we want to be both RESTful and pretty, we could use this code...

	map.outlaw_resources :news, :provide=>[:restful,:pretty]

...which maps these routes...

	Route name        Sample URL path       GET    POST   PUT    DELETE
	----------------- --------------------- ------ ------ ------ ------
	news_root         news                  index  create
	news_index        news/index            index
	news_new          news/new              new
	news_create       news/create                  create
	news_id           news/228              show          update destroy
	news_id_show      news/228/show         show
	news_id_edit      news/228/edit         edit
	news_id_update    news/228/update                     update
	news_id_destroy   news/228/destroy                           destroy

Notice there are now two ways to get to each of the actions, except for `new`
and `edit`, since the RESTful and pretty forms of those two routes are identical.

Nested Resources
----------------

In the config/routes.rb script, this code...

	map.outlaw_resources :blog, :has_many=>:article

...or alternatively, this code...

	map.outlaw_resources :blog do |blog|
	  blog.outlaw_resources :article
	end

...will give you these routes:

	Route name              Sample URL path        GET    POST   PUT    DELETE
	----------------------- ---------------------- ------ ------ ------ ------
	blog_root               blog                   index  create
	blog_index              blog/index             index
	blog_new                blog/new               new
	blog_id                 blog/5                 show          update destroy
	blog_id_edit            blog/5/edit            edit
	blog_id_article_root    blog/5/article         index  create
	blog_id_article_index   blog/5/article/index   index
	blog_id_article_new     blog/5/article/new     new
	blog_id_article_id      blog/5/article/12      show          update destroy
	blog_id_article_id_edit blog/5/article/12/edit edit

Here are some sample Rails expressions that reference the above routes:

	blog_index_path                                   # "/blog/index"
	blog_new_path                                     # "/blog/new"
	blog_id_path(blog_id)                             # "/blog/15"
	blog_id_article_index_path(blog_id)               # "/blog/15/article/index"
	blog_id_article_id_root_path(blog_id, article_id) # "/blog/15/article/203"
	blog_id_article_id_edit_path(blog_id, article_id) # "/blog/15/article/203/edit"

Note that the Outlaw route names closely follow the URL paths, and don't mix
the singular and plural forms of the same word unless asked to. Compare to
the traditional Rails routes which would've done the same jobs:

	blogs_path                                        # "/blogs"
	new_blog_path                                     # "/blogs/new"
	blog_path(blog_id)                                # "/blogs/15"
	blog_articles_path(blog_id)                       # "/blogs/15/articles"
	blog_article_path(blog_id, article_id)            # "/blogs/15/articles/203"
	edit_blog_article_path(blog_id, article_id)       # "/blogs/15/articles/203/edit"

Maintaining Backward Compatibility
----------------------------------

If you're writing a new application from scratch, you need not be concerned with
these code migration techniques. You can refrain from using any classic routes at all.
If you want to introduce some Outlaw routes into an existing Rails application which
uses the traditional route conventions, you can do so as described here. (See
`doc/syntax_tools` for code migration tools.)

Suppose you have this line in your routes.rb script...

	map.resources :users

...and you change it to this...

	map.outlaw_resources :user, :provide=>[:classic,:default], :controller=>:users

This should give you perfect compatibility with all your existing code, along with a
bunch of new routes to begin playing with:

	Route name      Sample URL path   GET    POST   PUT    DELETE
	--------------- ----------------- ------ ------ ------ ------
	users           users             index  create
	new_user        users/new         new
	user            users/1           show          update destroy
	edit_user       users/1/edit      edit
	
	user_root       user              index  create
	user_index      user/index        index
	user_new        user/new          new
	user_id         user/1            show          update destroy
	user_id_edit    user/1/edit       edit

One of your views might contain...

	<%= link_to "My profile page", user_path(@user_id) %>

...which, if `@user_id` is 712, might generate the HTML code...

	<a href="/users/712">My profile page</a>

Some other code, perhaps in the same file (even the same line a week later) might be...

	<%= link_to "My profile page", user_id_path(@user_id) %>

...to generate the HTML...

	<a href="/user/712">My profile page</a>

When a visitor clicks on either of these links, the browser will issue one of
two possible HTTP requests:

	either     GET /users/712
	or         GET /user/712

Since none of the route names or URLs overlap, and since both requests map to the
`show` action of the `users` (or `user`\*) controller, you can intermingle
the use of `user_path()` and `user_id_path()` in your code, for the same ultimate
effect.

>\* Controller names are fully independent of model names. Controllers that
mostly operate on one particular data model are traditionally named after that
model, in the plural form as in `users_controller.rb`, but a programmer can
diverge from this convention without risking a name conflict. Since not all
controllers are associated with a data model, Rails controllers need to allow
arbitrary names. Depending on its primary purpose, a controller can be completely
decoupled from the structure of the data. Once created, a controller's name is
only linked to the rest of the code by all the references to that controller.
There is no Rails behavior which dynamically pluralizes or singularizes a
controller's class or file name after it has been created, so as long as all your
code uses the correct controller name, whether singular, plural, or gibberish,
everything will work fine.

At some future time, you may want to entirely abandon classic routes. To do this, you
just replace all instances of `user_path()` with `user_id_path()`, and `users_url()`
with `user_root_url()`, and so on. Then remove the `:classic` request from the relevant
`:provide` option in `routes.rb` and run your tests. (You do have good tests or behavior
scripts, don't you?) This should exercise all your code and expose any references to the
old routes you may have missed.

-------------------------------------------------------------------------------

Syntax reference manual
=======================

The method calls follow these prototypes:

**`outlaw_resources(resource_name, [resource_name,...], options, &code_block)`**  
**`outlaw_resource(resource_name, [resource_name,...], options, &code_block)`**  

These two methods are analogous to ActionController::Routing::RouteSet::Mapper#resource()
and Mapper#resources() in Rails core. These are the two principal methods used in Outlaw
routing. Their usage details are covered throughout this document.

In most circumstances, the singular is the preferred form for all `resource_name` arguments.
Pluralization is fully supported by these methods, but they're designed in such a way as to
have no internal need for such behavior, and to function perfectly well with the inflector
completely disabled. If you're not sure whether to provide a singular or plural noun as a
resource name, you should probably use a singular resource name, whether you're calling
`outlaw_resource` or `outlaw_resources`.

### Options: Singular and Plural

**`:singular`** `String` or `Symbol`  
Specify the singular form of the name to be used in the generated routes. If this option is
specified and `:plural` is not, the `resource_name` parameter is assumed to be a plural. Under
normal circumstances, you'll never need this option.  

**`:plural`** `String` or `Symbol`  
Specify the plural form of the name to be used in the generated routes. If this option is
specified and `:singular` is not, the `resource_name` parameter is assumed to be a singular.
This option is handy if your inflector is disabled or incorrectly pluralizing your resource
name, but even so, it's only needed in connection with classic routes or with the option
`:plural_controllers=>true`.

An alternative method of specifying singulars and plurals is to use a two-element array as
the resource name instead of a symbol or string (see the section discussing singular/plural
specification).

Under normal circumstances, Outlaw Resources don't distinguish between singulars or plurals.
Any identifier used as a resource name is never modified in any context, with the exception
of "classic" routes and plural controller names. Unless classic routes or plural controllers
are called for, there's no need to consider multiple forms of a resource name. Everywhere else,
the resource name is used as-is (probably singular).

### Options: Which Routes to Generate

**`:provide`** `String`, `Symbol`, or `Array` (inherited by inner code blocks)  
Specifies which routes are to be mapped. If no `:provide` option is specified, it is implicitly
set to the default set of routes (`:default`). This option receives a route mnemonic or an array
of route mnemonics (see section discussing route mnemonics).

**`:omit`** `String`, `Symbol`, or `Array` (inherited by inner code blocks)  
Specifies which routes are *not* to be mapped. This option receives a route mnemonic or an array
of route mnemonics (see section discussing route mnemonics). The `:omit` option takes precedence
over the `:provide` option.

Taken together, `:provide` and `:omit` declare which routes are to be mapped. The `:provide`
option nominates a set of routes for inclusion, and the `:omit` option pares down that set of
routes. A route is mapped only if it is listed in the `:provide` option (set to the `:default`
mnemonic by default), *and is not* listed in the `:omit` option (set empty by default).

**`:only`** `String`, `Symbol`, or `Array` (not inherited by inner code blocks)  
**`:except`** `String`, `Symbol`, or `Array` (not inherited by inner code blocks)  
Specify which of the seven default actions should be routed to. :only and :except may be set to
:all, :none, an action name or a list of action names. By default, routes are generated for all
the standard actions.

For example:

	map.outlaw_resources :post, :only=>[:index,:show] do |post|
	  post.outlaw_resources :comment, :except=>[:update,:destroy]
	  end

...will map these...

	yes               post_root GET    /post                           PostController#index
	no                          POST   /post                           PostController#create
	yes              post_index GET    /post/index                     PostController#index
	no                 post_new GET    /post/new                       PostController#new
	yes                 post_id GET    /post/:id                       PostController#show
	no                          PUT    /post/:id                       PostController#update
	no                          DELETE /post/:id                       PostController#destroy
	no             post_id_edit GET    /post/:id/edit                  PostController#edit
	yes    post_id_comment_root GET    /post/:post_id/comment          CommentController#index
	yes                         POST   /post/:post_id/comment          CommentController#create
	yes   post_id_comment_index GET    /post/:post_id/comment/index    CommentController#index
	yes     post_id_comment_new GET    /post/:post_id/comment/new      CommentController#new
	yes      post_id_comment_id GET    /post/:post_id/comment/:id      CommentController#show
	no                          PUT    /post/:post_id/comment/:id      CommentController#update
	no                          DELETE /post/:post_id/comment/:id      CommentController#destroy
	yes post_id_comment_id_edit GET    /post/:post_id/comment/:id/edit CommentController#edit

Don't confuse these options with the `:provide` and `:omit` options. While the functionality
of the two approaches often overlaps, they are not identical. `:only` and `:except` were
introduced in Rails 2.3 and are supported for compatibility. The `:only` and `:expept` options
receive action names, while `:provide` and `:omit` receive route mnemonics.

**`:collection`** Hash  
**`:member`** Hash  
**`:new`** Hash  

Add named routes for additional actions that operate on the collection as a whole, individual
members of the collection, or requests for a new record. Takes a hash in the form of
{action=>method,...}, where method is :get/:post/:put/:delete, an array of any of those
symbols, or :any.

  map.outlaw_resources :headline, :provide=>:all, :collection=>{:rss=>:any}
    # Some of the routes generated:
    # rss_headlines_url         /headlines/rss     {:action=>"rss", :controller=>"headline"}
    # headline_rss_url          /headline/rss      {:action=>"rss", :controller=>"headline"}
  map.outlaw_resources :message, :provide=>:all, :member=>{:flag=>[:get,:post]}
    # flag_message     GET,POST /messages/:id/flag {:action=>"flag", :controller=>"message"}
    # message_id_flag  GET,POST /message/:id/flag  {:action=>"flag", :controller=>"message"}
  map.outlaw_resources :order, :provide=>:all, :new=>{:coupon=>:get}
    # coupon_new_order GET      /orders/new/coupon {:action=>"coupon", :controller=>"order"}
      # order_new_coupon GET      /order/new/coupon  {:action=>"coupon", :controller=>"order"}

### Options: Controllers

**`:plural_controllers`** `true` or **`false`** (inherited by inner code blocks)  
Setting to `true` causes the plural version of the resource name to be used as the controller
name. Otherwise, the singular name is used. Note that by default, singular controller names
are used, which is the opposite of the behavior of the `resources` and `resource` methods.

**`:controller`** `String` or `Symbol`  
Specify a controller name for the routes' destination bindings.

**`:namespace`** `String` (inherited by inner code blocks)  
Specify a string to be appended to the front of the controller names, which is probably a
directory name with trailing slash. Inherited by inner code blocks.

### Options: Route Names

**`:name_prefix`** `String` or `Symbol`  
Define a prefix for all generated routes, usually ending in an underscore. Route names
are only used in the Ruby code, and are not usually seen by the application's users.
Use this if you have named routes that may clash.

	map.outlaw_resources :tag, :path_prefix=>'/book/:book_id', :name_prefix=>'book_'
	map.outlaw_resources :tag, :path_prefix=>'/toy/:toy_id',   :name_prefix=>'toy_'

You may also use :name_prefix to override the generic named routes in a nested resource,
like so...

	map.outlaw_resources :article do |a|
	  a.outlaw_resources :comment, :name_prefix=>nil ; end
	# Sampling of routes:
	# article_root  /article
	# article_id    /article/:id
	# comment_root  /article/:article_id/comment      (compare article_id_comment_root)
	# comment_id    /article/:article_id/comment/:id  (compare article_id_comment_id)

**`:outlaw_name_prefix`** `String`  
**`:classic_name_prefix`** `String`  
Same as `:name_prefix`, but is only applied to "outlaw" or "classic" routes. Where they apply,
these more specific options take precedence over the more general `:name_prefix` option.

	map.outlaw_resources :page, :provide=>:all, :classic_name_prefix=>'historical_'
	# Sampling of routes:
	# historical_pages /pages
	# historical_page  /pages/:id
	# page_root        /page
	# page_id          /page/:id

**`:root_name_suffix`** `String` (inherited by inner code blocks)  
Specify characters to be appended to the end of the outlaw collection route name.
By default, this option is "`_root`".

	map.outlaw_resources :account, :root_name_suffix=>nil
	# Here the /account route is named "account" instead of "account_root"
	map.outlaw_resources :account, :root_name_suffix=>nil, :provide=>:all
	# Here there's a name clash, since both classic and outlaw routes are mapped.

**`:id_root_name_suffix`** `String` (inherited by inner code blocks)  
Specify characters to be appended to the end of the route name of the outlaw member route.
By default, this option is blank.

	map.outlaw_resources :account, :id_root_name_suffix=>'_root'
	# Here the /account/:id route is named "account_id_root" instead of "account_id"

**`:id_name_suffix`** `String` (inherited by inner code blocks)  
Specify characters to be inserted into the names of non-classic routes which reference an
individual member resource. That is, the routes referenced by mnemonics `:member`, `:show`,
`:edit`, `:update`, and `:destroy`, will have this string embedded into their route names.
While this suffix may sometimes be embedded in front of other suffixes, if you want an
underscore to set it off from the rest of a name, that underscore probably belongs on the
left. By default, this option is "`_id`".

	map.outlaw_resources :catalog, :id_name_suffix=>'_item'
	# Makes routes with names like "catalog_item_destroy" instead of "catalog_id_destroy"

### Options: URL Paths

**`:as`** `String` or `Symbol`  
Specify a resource name to use in the URL paths.

**`:path_names`** `Hash`  
Specify names for the `new`, `edit`, or similar actions, as a hash in the form.

	map.outlaw_resources :product, :as=>'producto', :path_names=>{:new=>'nuevo', :edit=>'editar'}
	# path for new product:  /producto/nuevo
	# path for edit product: /producto/editar

You can also set default action names from an environment.

	config.action_controller.resources_path_names = {:new=>'nuevo', :edit=>'editar'}

**`:path_prefix`** `String`  
Set a prefix to the routes' URL paths. These prefixes may contain dynamic fields
(segments with leading colons).

	map.outlaw_resources :comment, :provide=>:classic, :path_prefix=>'/articles/:article_id'
	map.outlaw_resources :comment, :provide=>:outlaw, :path_prefix=>'/article/:article_id'
	# These make a set of routes with paths including:
	# /articles/:article_id/comments        (Classic comment collection)
	# /articles/:article_id/comments/:id    (Classic comment member)
	# /article/:article_id/comment/root     (Outlaw comment collection)
	# /article/:article_id/comment/:id      (Outlaw comment member)

**`:outlaw_path_prefix`** `String`  
**`:classic_path_prefix`** `String`  
Same as `:path_prefix`, but is only applied to "outlaw" or "classic" routes. Where they apply,
these more specific options take precedence over the more general `:path_prefix` option.

	map.outlaw_resources :comment, :provide=>:all,
	                     :classic_path_prefix=>'/articles/:article_id', # For classic routes
	                     :path_prefix        =>'/article/:article_id'   # For all others
	# Makes a set of routes with paths including:
	# /articles/:article_id/comments        (Classic comment collection)
	# /articles/:article_id/comments/:id    (Classic comment member)
	# /article/:article_id/comment          (Outlaw comment collection)
	# /article/:article_id/comment/:id      (Outlaw comment member)

### Options: Nesting

**`:has_one`**  `Symbol`, `String`, or `Array`  
Specify nested resources, this is a shorthand for mapping singleton resources beneath the current.

**`:has_many`** `Symbol`, `String`, or `Array`  
Same as `:has_one`, but for nesting collection resources.

You may directly specify the routing association with `:has_one` and `:has_many` like this...

	map.outlaw_resources :note, :has_one=>:author, :has_many=>[:comment,:attachment]

This is the same as...

	map.outlaw_resources :note do |note|
	  note.outlaw_resource  :author
	  note.outlaw_resources :comment
	  note.outlaw_resources :attachment ; end

**`:shallow`** `true` or **`false`** (inherited by inner code blocks)  
If `true`, nested resources which reference a specific member (ie. those with an :id
parameter) will not use the parent path prefix or name prefix.

The `:shallow` option is inherited by any nested code block.
For example, `user`, `post` and `comment` all use shallow paths with these nested resources:

	map.outlaw_resources :user, :shallow=>true do |user|
	  user.outlaw_resources :post do |post|
	    post.outlaw_resources :comment
	  end ; end
	# Makes a set of routes with paths including:
	# user_id_post_index    GET /user/1/post/index
	# post_id               GET /post/2
	# post_id_comment_index GET /post/2/comment/index
	# comment_id_edit       GET /comment/5/edit

You may also use `:shallow` in combination with the `:has_one` and `:has_many` options.

	map.outlaw_resources :user, :has_many=>{:post=>:comment}, :shallow=>true

"Dry Mapping" Methods
---------------------

There may be times when, instead of mapping a set of routes to the Rails routing system,
you'd like to return an array of descriptions of those routes. Perhaps you'd like an
additional level of control not offered by any of the built-in options.

**`outlaw_resource_descriptor_array(...)`** => Array  
**`outlaw_resources_descriptor_array(...)`** => Array  
Take the same arguments and optional code block as `outlaw_resource()`, and
`outlaw_resources()`, but instead of mapping the requested routes, an array representing
those routes is returned. This array can then be programatically manipulated, and
possibly mapped by the calling code. The return value is an array of hashes. Each
element of the array represents an individual named or anonymous route, in order of
precedence. These hashes always have the keys `:path` and `:options`, where `:path`
is a String representation of the path and `:options` is a Hash (which may be empty),
representing any special options for the route. If the route has a name, there will
also be a `:name` key with a String representing the name.

If a dry-mapper method receives a code block, that inner code block should not
itself contain a dry-mapping method call, but instead should use ordinary calls to
`outlaw_resources` or `outlaw_resource` or `resources` or `resource`. Otherwise,
the inner calls' routes will not accrue to the outer call's array.

	# In config/routes.rb , inside ActionController::Routing::Routes.draw do |map|
	route_array = map.outlaw_resources_descriptor_array(:article) do |article|
	                article.outlaw_resources(:thread) do |thread| # Not a dry-map!
	                  thread.outlaw_resources(:comment) ; end ; end

**`map_from_route_descriptor_array(route_descriptor_array)`**  
This is not actually a dry mapping method. It maps a set of routes defined in
`route_descriptor_array`, in sequence from first to last. The array is assumed to be
of the format returned by the dry mapper methods `outlaw_resource_descriptor_array`
and `outlaw_resources_descriptor_array`. This makes it convenient for your code to
generate an array of route descriptors using one of those methods, and then manipulate
that array before passing it to this method to actually map the routes. In this way,
your code can go beyond what is possible using the method options, and directly modify
the route descriptors to your liking.

**`outlaw_resource_ruby_code_array(...)`** => Array  
**`outlaw_resources_ruby_code_array(...)`** => Array  
Like `outlaw_resources_descriptor_array`, but instead of returning an array of route
descriptor hashes, it returns an array of Strings containing a line of Ruby code in
the form, "`named_route("name","path",{option_key=>option_value,...})`" or
"`connect("path",{option_key=>option_value,...})`".
The array is sequenced by execution order, such that if executed form top to bottom,
the correct routing precedence order will result. In order to actually execute these,
you'll probably need to tack on a "`map.`" sequence to the left side of each line of
code. As with `outlaw_resource_descriptor_array`, dry-mapping methods in inner code
blocks will not propagate to outer arrays; use ordinary resource methods for that.

	# In config/routes.rb , inside ActionController::Routing::Routes.draw do |map|
	ruby_array = map.outlaw_resources_ruby_code_array(:article) do |article|
	               article.outlaw_resources(:thread) do |thread| # Not a dry-map!
	                 thread.outlaw_resources(:comment) ; end ; end
	# Do some stuff to the ruby_array
	ruby_array.each {|line_of_code| eval("map.#{line_of_code}") }

Specifying Singulars and Plurals
--------------------------------

The `outlaw_resources` and `outlaw_resource` methods take resource names as arguments.
Normally, those resource arguments are used as-is, without attempts to pluralize or
singularize the identifiers. These methods are designed to function perfectly well
with or without the inflector enabled. If you like to keep your inflector active,
the `outlaw_resources` methods will use it when it needs to pluralize or singularize
an identifier. If your inflector is disabled, you have several options for syntactically
specifying singulars and plurals.

Under normal circumstances, Outlaw Resources don't distinguish between singulars or plurals.
Any identifier used as a resource name is never modified in any context, with the exception
of "classic" routes and pluralized controller names. Unless classic routes or plural
controllers are called for, there's no need to consider multiple forms of a resource name.
Everywhere else, the resource name is used as-is (probably singular).

In addition to taking a `:singular` and `:plural` option, there is an unusual way of
specifying singulars and plurals as the `outlaw_resources` resource name parameter. Instead of
sending a `Symbol` or a `String`, you can give a two-element `Array` of symbols or strings.
Such an array follows the form `[singular,plural]`.

For example...

	map.outlaw_resources([:spumoni,:spumonae], :provide=>:all)

...has the same effect as...

	map.outlaw_resources(:spumoni, :plural=>:spumonae, :provide=>:all)

This syntax is not just a convenience. This would be impossible without it...

	map.outlaw_resources([:spumoni,:spumonae], [:fish,:fishies], :provide=>:all)

This syntax may also be passed to the `:has_one` and `:has_many` options. When doing so,
there may be times when it's ambiguous whether you mean "two resource names which are to
be auto-pluralized by the inflector" or, "the singular and plural form of a single resource
name". This ambiguity only arrises when there are two elements of an array. In such cases,
the two-element array is assumed to be two independent resources.

	map.outlaw_resources :account, :provide=>:all, :has_many=>[:debit,:credit]

If you meant two forms of the same resource name, you'll need to wrap the array within
another array. Such a structure means "an array of resources containing a single resource,
which is described by both the singular and plural form of its name." Like so:

	map.outlaw_resources :user, :provide=>:all, :has_many=>[[:persona,:personae]]

Route Mnemonics
---------------

Some of the options of `outlaw_resource` and `outlaw_resources` allow the calling code
to refer to individual routes or classes of routes. Such options recognize a set of
keywords (as Strings, Symbols, or arrays of Strings or Symbols), which target the
effects of those options on particular routes. It's important to understand that the
route mnemonics only have meaning within the `outlaw_resource` and `outlaw_resources`
methods. There is no durable connection between the route mnemonics and the actual
routes that get generated. The mnemonics just provide a convenient means of identifying
which possible routes are to be affected by the resource generation options.

### Composite mnemonics

It is convenient to refer to broad groupings of routes under a single identifier. These
groupings are called "composite" route mnemonics.

Composite mnemonics:

	Composite mnemonic  Equivalent to
	------------------- -----------------------------------------
	restful             collection, new, member, edit
	pretty              index, new, create, show, edit, update, destroy
	classic             classic_collection, classic_new, classic_member, classic_edit
	default             restful, index
	outlaw              restful, pretty
	all                 restful, pretty, classic
	none                (empty)

### Elemental mnemonics

An elemental route mnemonic is one which cannot be specified with any inner level of
detail. Thus, a composite mnemonic refers to a collection of other ("smaller") mnemonics,
while an elemental mnemonic is the most precise addressing possible for mnemonics. Note
that an elemental mnemonic can refer to more than one route, since a separate Rails route
is generated for each of the associated HTTP verbs. For example, the mnemonic 'collection'
refers to a set of two Rails routes--one for the GET verb and one for the POST verb.

A few elemental mnemonics:

	Elemental mnemonic    Typical name       Typical path
	-------------------   ------------------ ----------------
	collection            thing_root         /thing
	index                 thing_index        /thing/index
	show                  thing_id_show      /thing/12/show
	classic_member        thing              /things/12

Putting this all together, this code...

	map.outlaw_resources :account, :provide=>[:default,:show]

...will generate these routes:

	Route name       Sample path        Action set           (elemental mnemonic)
	---------------- ------------------ -------------------- -----------------------
	account_root     /account           index create         (collection)
	account_index    /account/index     index                (index)
	account_new      /account/new       new                  (new)
	account_id       /account/31        show update destroy  (member)
	account_id_show  /account/31/show   show                 (show)
	account_id_edit  /account/31/edit   edit                 (edit)

In the example, we see the array `[:default, :show]`. The symbol `:default`
represents `[:restful, :index]`. In turn, the symbol `:restful` represents
`[:collection, :new, :member, :edit]`.

So our example means exactly the same thing as if we'd written...

	map.outlaw_resources :account,
	                     :provide=>[ :collection, :index, :new, :member, :show, :edit ]

This generates a total of nine routes under six names.
