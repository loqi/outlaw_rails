# -*- coding: utf-8 -*-

# This is the main behavior script for Outlaw Resources.
# It's in the Outlaw indentation style, which is loosely similar to banner style.
# http://en.wikipedia.org/wiki/Indent_style#Banner_style
#
# Routes are mapped into an empty ActionController::Routing::RouteSet object
# referred to by @scratch_routes variable, and then they're verified for correctness.
# There are principally two techniques for checking behavior in here: One is to
# use the routes generated by the outlaw_resources() and outlaw_resource() methods;
# The other is to build an array of descriptors of the expected routes, and examine
# the ActionController::Routing::Routes object, to verify they are all present in the
# expected precedence order. The latter method is less forgiving of re-sequencing of
# the routing declarations. This can be a good thing where it matters, and not so
# good where it's not significant. If the production code is changed in such a way as
# to produce a different but valid sequence, this script must be adapted to reflect
# that new precedence order. Or, if you're feeling lazy and you're sure the sequence
# of the routes is not significant, you can just change the offending be_exact_routes
# line in this script to a be_assorted_routes instead.
#
# The basic way of building an expected route descriptor array is to copy a pre-
# defined archetypal list of routes, and then adjust the names, paths, and controllers,
# and possibly insert, remove, or nil-out some route descriptors in the array. Then
# that new array is compared against the actual routes in ActionController . Any
# differences are treated as unexpected behavior, and reported to the user with rather
# long messages. Using these methods, there are ways to designate I-don't-care zones
# (by putting nils in the expectation array), and then verify the routes are present
# in any order. There are also ways of looking for consecutive runs of routes, without
# concern for where the run falls within the full set of routes. And there are ways
# of verifying the presence of routes, without concern for any sequence whatsoever.
# Look for those techniques in this code.
#
# There is quite a bit of code repititition in here. Reading clarity is prioritized
# over DRYness and brevity. Even so, it takes a bit of effort to understand some of
# this code. Reading clarity is the goal, if imperfectly attained, on the assumption
# that an unfamiliar person is only interested in a little piece of code, and doesn't
# want to understand this whole script to figure out what's causing their problem. This
# means the maintainer of this script must do extra work keeping all the repetition in
# sync. So don't change anything in here without tracking down the similar code (probably
# all within the same 'it' block), and synchronizing it. Some 'it' blocks are similar to
# other 'it' blocks. Look for them too, when making changes.
#
# Most of the behaviors apply to outlaw_resources() vs. outlaw_resource() in similar
# ways. They also apply to [:classic] vs. [:classic,:restful,:pretty] in similar ways,
# as well. It's least confusing to organize these four permutations together under one
# 'it' block. So most of these 'it' blocks have at least four expectations in them
# (collection with everything, singleton with everything, collection with classics,
# singleton with classics). They are usually presented with collections directly above
# singletons, and the two everythings before the two classics. This is because the first
# one to fail will cause the others to be skipped. The collection-with-everything set gives
# the most descriptive user messages, and represent the most complete use case, so they are
# usually positioned fist. These "full monties" tend to use the compare-with-array technique
# of verification; the classic-only ones tend to use the technique of exercising the routes.
# Also, in normal use, you wouldn't likely write map.outlaw_resource([:singular,:plural])
# but would say map.outlaw_resource(:singular) . This script often uses the dual-form
# array when it's not totally appropriate, to test for pluralization leaks.
#
# This script takes a while to run, but not much sneaks past it.

require "#{File.dirname(__FILE__)}/spec_helper_resources"
RT = RouteTester

describe ResourcesController, 'a call to outlaw_resources() and/or outlaw_resource()', :type=>:controller do
  before :all  do before_all ; end
  before :each do before_each ; end
  after  :each do after_each ; end
  after  :all  do after_all ; end
  it "correctly raises ArgumentError when given an invalid combination of arguments" do
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([]                        ) } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( []                        ) } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singu1,:plur1,:pplur1]  ) } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singu1,:plur1,:pplur1]  ) } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singu1,[:a,:b],'singu2']) } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singu1,[:a,:b],'singu2']) } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([[:a,:b],[:c,:d]]         ) } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [[:a,:b],[:c,:d]]         ) } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singu1,[:a,:b],'singu2']) } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singu1,[:a,:b],'singu2']) } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singu1,[:a,:b],'singu2']) } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singu1,[:a,:b],'singu2']) } }.should raise_error(ArgumentError)
    end
  it "correctly does not raise an error when given a valid combinations of arguments" do
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources(                                            ) } }.should_not raise_error
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource(                                             ) } }.should_not raise_error
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:a,:b],[:c,:d]                             ) } }.should_not raise_error
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:a,:b],[:c,:d]                             ) } }.should_not raise_error
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources(:singu1,'plur1'                             ) } }.should_not raise_error
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( :singu1,'plur1'                             ) } }.should_not raise_error
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources(:singu1,[:a,:b],'singu2'                    ) } }.should_not raise_error
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( :singu1,[:a,:b],'singu2'                    ) } }.should_not raise_error
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singu1,'singu1'],[:a,:b],['singu2',:plur2]) } }.should_not raise_error
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singu1,'singu1'],[:a,:b],['singu2',:plur2]) } }.should_not raise_error
    end
  it "assumes a Symbol or Sting as the resource name parameter represents a singular name" do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :singu101, :provide=>:classic }
    should_have_collec_classics    :singu101, :plur101, :controller=>'singu101'
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :singu101, :provide=>:classic }
    should_have_singleton_classics :singu101

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources 'singu102', :provide=>:classic }
    should_have_collec_classics    :singu102, :plur102, :controller=>'singu102'
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  'singu102', :provide=>:classic }
    should_have_singleton_classics :singu102
    end
  it 'handles multiple resource names listed as parameters' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :singu101, :singu102, :provide=>:classic }
    should_have_collec_classics    :singu101, :plur101
    should_have_collec_classics    :singu102, :plur102
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :singu101, :singu102, :provide=>:classic }
    should_have_singleton_classics :singu101
    should_have_singleton_classics :singu102
    end
  it 'handles a mixture of Symbols, Strings, and singular-plural Arrays, as a list of resource names' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :singu101,[:message,:messages],'singu102', :provide=>:classic }
    should_have_collec_classics    :singu101, :plur101
    should_have_collec_classics    :message , :messages
    should_have_collec_classics    :singu102, :plur102
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :singu101,[:message,:messages],'singu102', :provide=>:classic }
    should_have_singleton_classics :singu101
    should_have_singleton_classics :message
    should_have_singleton_classics :singu102

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources ['message',:messages],[:comment,'comments'], :provide=>:classic }
    should_have_collec_classics    :message, :messages
    should_have_collec_classics    :comment, :comments
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  ['message',:messages],[:comment,'comments'], :provide=>:classic }
    should_have_singleton_classics :message
    should_have_singleton_classics :comment

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singu101,:plur102], :provide=>:classic }
    should_have_collec_classics    :singu101, :plur102
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singu101,:plur102], :provide=>:classic }
    should_have_singleton_classics :singu101

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singu101,:plur102], ['singu103','plur104'], :singu105, :singu106, :provide=>:classic }
    should_have_collec_classics    :singu101, :plur102
    should_have_collec_classics    :singu103, :plur104
    should_have_collec_classics    :singu105, :plur105
    should_have_collec_classics    :singu106, :plur106
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singu101,:plur102], ['singu103','plur104'], :singu105, :singu106, :provide=>:classic }
    should_have_singleton_classics :singu101
    should_have_singleton_classics :singu103
    should_have_singleton_classics :singu105
    should_have_singleton_classics :singu106

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singu101,:plur102], :singu103, [:singu104,:plur105], :plural=>:plur106, :provide=>:classic }
    should_have_collec_classics    :singu101,:plur102
    should_have_collec_classics    :singu103,:plur106
    should_have_collec_classics    :singu104,:plur105
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singu101,:plur102], :singu103, [:singu104,:plur105], :plural=>:plur106, :provide=>:classic }
    should_have_singleton_classics :singu101
    should_have_singleton_classics :singu103
    should_have_singleton_classics :singu104
    end
  it "correctly raises ArgumentError when given an invalid :provide option" do
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources(:message ,:plural=>:messages ,:provide=>:inval ) } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( :message ,:plural=>:messages ,:provide=>:inval ) } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources(:message ,:plural=>:messages ,:provide=>'inval') } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( :message ,:plural=>:messages ,:provide=>'inval') } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources(:message ,:plural=>:messages ,:provide=>/none/ ) } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( :message ,:plural=>:messages ,:provide=>/none/ ) } }.should raise_error(ArgumentError)
    end
  it "applies the :provide option, to generate various combinations of routes" do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singular,:plural]) }
    RT.default_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singular,:plural], :provide=>:default) }
    RT.default_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singular,:plural]) }
    RT.s_default_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singular,:plural], :plovide=>[:default]) }
    RT.s_default_route_ar.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singular,:plural] ,:provide=>[]) }
    [].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singular,:plural] ,:provide=>[]) }
    [].should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singular,:plural] ,:provide=>[:classic]) }
    RT.classic_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singular,:plural] ,:provide=>[:classic]) }
    RT.s_classic_route_ar.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singular,:plural] ,:provide=>:restful) } # May be Array, Symbol, or String.
    RT.restful_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singular,:plural] ,:provide=>:restful) } # May be Array, Symbol, or String.
    RT.s_restful_route_ar.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singular,:plural] ,:provide=>[:pretty]) }
    RT.pretty_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singular,:plural] ,:provide=>[:pretty]) }
    RT.s_pretty_route_ar.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singular,:plural] ,:provide=>[:classic,:default]) }
    RT.classic_plus_default_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singular,:plural] ,:provide=>[:default,:classic]) }
    RT.s_classic_plus_default_route_ar.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singular,:plural] ,:provide=>[:pretty,:classic]) }
    RT.classic_plus_pretty_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singular,:plural] ,:provide=>[:pretty,:classic]) }
    RT.s_classic_plus_pretty_route_ar.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singular,:plural] ,:provide=>[:restful,:classic]) }
    RT.classic_plus_restful_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singular,:plural] ,:provide=>[:restful,:classic]) }
    RT.s_classic_plus_restful_route_ar.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singular,:plural] ,:provide=>[:restful,:pretty]) }
    RT.pretty_plus_restful_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singular,:plural] ,:provide=>[:restful,:pretty]) }
    RT.s_pretty_plus_restful_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singular,:plural] ,:provide=>[:outlaw         ]) }
    RT.pretty_plus_restful_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singular,:plural] ,:provide=> :outlaw          ) }
    RT.s_pretty_plus_restful_route_ar.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singular,:plural] ,:provide=>[:restful,:classic,:pretty]) }
    RT.all_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singular,:plural] ,:provide=>[:restful,:classic,:pretty]) }
    RT.s_all_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singular,:plural] ,:provide=>[:all                     ]) }
    RT.all_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singular,:plural] ,:provide=> :all                      ) }
    RT.s_all_route_ar.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singular,:plural] ,:provide=>[:index]) }
    [RT.pretty_index].should be_exact_routes
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singular,:plural] ,:provide=>[:index]) }
      }.should raise_error(ArgumentError)
    end
  it "applies the :omit option, to exclude specified routes from generation" do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources([:singular,:plural] ,:provide=>[:classic_member,:pretty], :omit=>[:create,:update]) }
    [nil, nil, nil, RT.pretty_index, RT.pretty_new, RT.pretty_show, RT.pretty_edit, RT.pretty_destroy].should be_exact_routes
    [RT.classic_show, RT.classic_update, RT.classic_destroy].should be_assorted_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource( [:singular,:plural] ,:provide=>[:classic_member,:pretty], :omit=>[:create,:update]) }
    [nil, nil, nil, nil, RT.s_pretty_new, RT.s_pretty_show, RT.s_pretty_edit, RT.s_pretty_destroy].should be_exact_routes
    [RT.s_classic_show, RT.s_classic_create, RT.s_classic_update, RT.s_classic_destroy].should be_assorted_routes
    end
  it "understands symbols or strings specified for the :only option" do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:classic, :only=>:show }
    [RT.classic_show].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :only=>'show' }
    [RT.classic_show, RT.restful_show, RT.pretty_show].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:classic, :only=>'show' }
    [RT.s_classic_show].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :only=>:show }
    [RT.s_classic_show, RT.s_restful_show, RT.s_pretty_show].should be_exact_routes
    end
  it "understands symbols or strings specified for the :except option" do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:classic, :except=>'destroy' }
    RT.classic_route_ar.but_without(RT.classic_destroy).should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :except=>:destroy }
    RT.all_route_ar.but_without(RT.classic_destroy, RT.restful_destroy, RT.pretty_destroy).should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:classic, :except=>:destroy }
    RT.s_classic_route_ar.but_without(RT.s_classic_destroy).should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :except=>'destroy' }
    RT.s_all_route_ar.but_without(RT.s_classic_destroy, RT.s_restful_destroy, RT.s_pretty_destroy).should be_exact_routes
    end
  it "understands arrays specified for the :only option" do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:classic, :only=>[:show,:index] }
    [RT.classic_index, RT.classic_show].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :only=>['show',:index] }
    [RT.classic_index, RT.classic_show, RT.restful_index, RT.pretty_index, RT.restful_show, RT.pretty_show].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:classic, :only=>[:show,'destroy'] }
    [RT.s_classic_show, RT.s_classic_destroy].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :only=>['show','destroy'] }
    [RT.s_classic_show, RT.s_classic_destroy, RT.s_restful_show, RT.s_pretty_show, RT.s_pretty_destroy].should be_exact_routes
    end
  it "understands arrays specified for the :except option" do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:classic, :except=>['destroy','update'] }
    RT.classic_route_ar.but_without(RT.classic_update, RT.classic_destroy).should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :except=>[:destroy,:update] }
    RT.all_route_ar.but_without(RT.classic_destroy, RT.classic_update, RT.restful_update, RT.restful_destroy, RT.pretty_update, RT.pretty_destroy).should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:classic, :except=>[:destroy,:update] }
    RT.s_classic_route_ar.but_without(RT.s_classic_update, RT.s_classic_destroy).should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :except=>['destroy',:update] }
    RT.s_all_route_ar.but_without(RT.s_classic_update, RT.s_classic_destroy, RT.s_restful_update, RT.s_restful_destroy, RT.s_pretty_update, RT.s_pretty_destroy).should be_exact_routes
    end
  it ":except and :only options understand :all parameter" do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:classic, :only=>:all }
    RT.classic_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :only=>:all }
    RT.all_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:classic, :only=>:all }
    RT.s_classic_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :only=>:all }
    RT.s_all_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:classic, :except=>:all }
    [].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :except=>:all }
    [].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:classic, :except=>:all }
    [].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :except=>:all }
    [].should be_exact_routes
    end
  it ":except and :only options understand :none parameter" do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:classic, :only=>:none }
    [].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :only=>:none }
    [].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:classic, :only=>:none }
    [].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :only=>:none }
    [].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:classic, :except=>:none }
    RT.classic_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :except=>:none }
    RT.all_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:classic, :except=>:none }
    RT.s_classic_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :except=>:none }
    RT.s_all_route_ar.should be_exact_routes
    end
  it ":only overrules :except when both options are specified" do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :except=>[:show,:new], :only=>[:show,:index] }
    [RT.classic_index, RT.classic_show, RT.restful_index, RT.pretty_index, RT.restful_show, RT.pretty_show].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :except=>[:show,:new], :only=>[:show,:destroy] }
    [RT.s_classic_show, RT.s_classic_destroy, RT.s_restful_show, RT.s_pretty_show, RT.s_pretty_destroy].should be_exact_routes
    end
  it "maps only the user-defined routes when :except=>:all and :collection=>{...} are specified together" do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:product,:products], :provide=>:classic, :except=>:all, :collection=>{:sale=>:get} }
    [ { :name=>'sale_products', :verb=>'GET', :path=>"/products/sale(.:format)", :action=>'sale', :controller=>'product' }
      ].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:product,:products], :provide=>:all    , :except=>:all, :collection=>{:sale=>:get} }
    [ { :name=>'sale_products', :verb=>'GET', :path=>"/products/sale(.:format)", :action=>'sale', :controller=>'product' },
      { :name=>'product_sale' , :verb=>'GET', :path=>"/product/sale(.:format)" , :action=>'sale', :controller=>'product' }
      ].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource [:product,:products], :provide=>:classic, :except=>:all, :collection=>{:sale=>:get} }
    [ { :name=>'sale_product', :verb=>'GET', :path=>"/product/sale(.:format)", :action=>'sale', :controller=>'product' }
      ].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource [:product,:products], :provide=>:all    , :except=>:all, :collection=>{:sale=>:get} }
    [ { :name=>'sale_product', :verb=>'GET', :path=>"/product/sale(.:format)", :action=>'sale', :controller=>'product' },
      { :name=>'product_sale', :verb=>'GET', :path=>"/product/sale(.:format)", :action=>'sale', :controller=>'product' }
      ].should be_exact_routes
    end
  it "maps only the user-defined routes when :except=>:all and :member=>{...} are specified together" do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:product,:products], :provide=>:classic, :except=>:all, :member=>{:preview=>:get} }
    [ { :name=>'preview_product', :verb=>'GET', :path=>"/products/:id/preview(.:format)", :action=>'preview', :controller=>'product' }
      ].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:product,:products], :provide=>:all    , :except=>:all, :member=>{:preview=>:get} }
    [ { :name=>'preview_product'   , :verb=>'GET', :path=>"/products/:id/preview(.:format)", :action=>'preview', :controller=>'product' },
      { :name=>'product_id_preview', :verb=>'GET', :path=>"/product/:id/preview(.:format)" , :action=>'preview', :controller=>'product' }
      ].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource [:product,:products], :provide=>:classic, :except=>:all, :member=>{:preview=>:get} }
    [ { :name=>'preview_product', :verb=>'GET', :path=>"/product/preview(.:format)", :action=>'preview', :controller=>'product' }
      ].should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource [:product,:products], :provide=>:all    , :except=>:all, :member=>{:preview=>:get} }
    [ { :name=>'preview_product', :verb=>'GET', :path=>"/product/preview(.:format)", :action=>'preview', :controller=>'product' },
      { :name=>'product_preview', :verb=>'GET', :path=>"/product/preview(.:format)", :action=>'preview', :controller=>'product' }
      ].should be_exact_routes
    end
  it 'does not normally generate any two routes with identical path+conditions+requirements' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :message, :plural=>:messages, :provide=>:classic }
    ActionController::Routing::Routes.routes.should have_distinct_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :message, :plural=>:messages, :provide=>:classic }
    ActionController::Routing::Routes.routes.should have_distinct_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :thread, :comment }
    ActionController::Routing::Routes.routes.should have_distinct_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :thread, :comment }
    ActionController::Routing::Routes.routes.should have_distinct_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:thread,:threads],[:comment,:comments], :provide=>:all }
    ActionController::Routing::Routes.routes.should have_distinct_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:thread,:threads],[:comment,:comments], :provide=>[:restful,:pretty] }
    ActionController::Routing::Routes.routes.should have_distinct_routes # :classic has some aliases of routes in :restful

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :singular, :plural=>:plural, :provide=>:all }
    ActionController::Routing::Routes.routes.should have_distinct_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :singular, :plural=>:plural, :provide=>[:restful,:pretty] }
    ActionController::Routing::Routes.routes.should have_distinct_routes
    end
  it 'routes "GET .../new" to an action, and does not route "POST .../new" to anything' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all }
    doing { ActionController::Routing::Routes.recognize_path('/plural/new'  ,:method=>:get)  }.should_not raise_error
    doing { ActionController::Routing::Routes.recognize_path('/singular/new',:method=>:get)  }.should_not raise_error
    doing { ActionController::Routing::Routes.recognize_path('/plural/new'  ,:method=>:post) }.should raise_error(ActionController::MethodNotAllowed)
    doing { ActionController::Routing::Routes.recognize_path('/singular/new',:method=>:post) }.should raise_error(ActionController::MethodNotAllowed)
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all }
    doing { ActionController::Routing::Routes.recognize_path('/plural/new'  ,:method=>:get)  }.should raise_error(ActionController::RoutingError)
    doing { ActionController::Routing::Routes.recognize_path('/singular/new',:method=>:get)  }.should_not raise_error
    doing { ActionController::Routing::Routes.recognize_path('/plural/new'  ,:method=>:post) }.should raise_error(ActionController::RoutingError)
    doing { ActionController::Routing::Routes.recognize_path('/singular/new',:method=>:post) }.should raise_error(ActionController::MethodNotAllowed)

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic }
    should_have_collec_refer_classics :message, :messages do |options|
      should_recognize options.merge(:action=>'new'), :path=>'/messages/new', :method=>:get
      doing { ActionController::Routing::Routes.recognize_path('/messages/new',:method=>:post)
        }.should raise_error(ActionController::MethodNotAllowed)
      end
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic }
    should_have_singleton_refer_classics :message         do |options|
      should_recognize options.merge(:action=>'new'), :path=>'/message/new' , :method=>:get
      doing { ActionController::Routing::Routes.recognize_path('/message/new' ,:method=>:post)
        }.should raise_error(ActionController::MethodNotAllowed)
      end
    end
  it 'incorporates ActionController::Base.resources_path_names into the generated routes' do
    begin
      orig_path_names = ActionController::Base.resources_path_names
      ActionController::Base.resources_path_names = {:new=>'nuevo',:edit=>'editar'}
      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all }
      RT.all_route_ar.collect {|orig_r| r = orig_r.dup
        r[:path] = r[:path].gsub(/\/new/,'/nuevo').gsub(/\/edit/,'/editar')
        r }.should be_exact_routes
      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all }
      RT.s_all_route_ar.collect {|orig_r| r = orig_r.dup
        r[:path] = r[:path].gsub(/\/new/,'/nuevo').gsub(/\/edit/,'/editar')
        r }.should be_exact_routes
      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic }
      new_path  = "/messages/nuevo"            ; new_options  = {:controller=>'message',:action=>'new'          }
      edit_path = "/messages/1#{@a_sep}editar" ; edit_options = {:controller=>'message',:action=>'edit',:id=>'1'}
      should_have_collec_refer_classics    :message, :messages do |options|
        should_recognize( options.merge(new_options) , :path=>new_path , :method=>:get ) ; end
      should_have_collec_refer_classics    :message, :messages do |options|
        should_recognize( options.merge(edit_options), :path=>edit_path, :method=>:get ) ; end
      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic }
      new_path  = "/message/nuevo"            ; new_options  = {:controller=>'message',:action=>'new'          }
      edit_path = "/message/editar"           ; edit_options = {:controller=>'message',:action=>'edit'         }
      should_have_singleton_refer_classics :message            do |options|
        should_recognize( options.merge(new_options) , :path=>new_path , :method=>:get ) ; end
      should_have_singleton_refer_classics :message            do |options|
        should_recognize( options.merge(edit_options), :path=>edit_path, :method=>:get ) ; end
    ensure
      ActionController::Base.resources_path_names = orig_path_names
    end ; end
  it "applies the :plural option, to specify a non-standard plural of the resource parameter" do
    # Don't be confused by the intentional mis-pairing of numbered resource names:
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :singu101           , :provide=>:classic, :plural=>:plur102 }
    should_have_collec_classics    :singu101, :plur102 # Left param is assumed to be singular when :plural but not :singular specified.
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :singu101           , :provide=>:classic, :plural=>:plur102 }
    should_have_singleton_classics :singu101

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singu101, nil    ], :provide=>:classic, :plural=>:plur102 }
    should_have_collec_classics    :singu101, :plur102 # :plural option is used when no plural is named in left param.
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singu101, nil    ], :provide=>:classic, :plural=>:plur102 }
    should_have_singleton_classics :singu101

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singu101,:plur102], :provide=>:classic, :plural=>:plur103 }
    should_have_collec_classics    :singu101, :plur102  # :plural option is ignored when a plural is named in left param.
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singu101,:plur102], :provide=>:classic, :plural=>:plur103 }
    should_have_singleton_classics :singu101
    end
  it "applies the :singular option, which causes an assumption that the resource parameter is a plural" do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :plur101            , :provide=>:classic, :singular=>:singu102 }
    should_have_collec_classics    :singu102, :plur101 # Left param is assumed to be plural when :singular but not :plural specified.
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :plur101            , :provide=>:classic, :singular=>:singu102 }
    should_have_singleton_classics :singu102

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [ nil     ,:plur101], :provide=>:classic, :singular=>:singu102 }
    should_have_collec_classics    :singu102, :plur101 # :singular option is used when no singular is named in left param.
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [ nil     ,:plur101], :provide=>:classic, :singular=>:singu102 }
    should_have_singleton_classics :singu102

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singu101,:plur102], :provide=>:classic, :singular=>:singu103 }
    should_have_collec_classics    :singu101, :plur102 # :singular option is ignored when a singular is named in left param.
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singu101,:plur102], :provide=>:classic, :singular=>:singu103 }
    should_have_singleton_classics :singu101
    end
  it "does not get confused when both :singular and :plural options are specified, " do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :singu101           , :provide=>:classic, :singular=>:singu102, :plural=>:plur103 }
    should_have_collec_classics    :singu101, :plur103 # Left param is singular when both options are given, and :singu opt is ignored.
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :singu101           , :provide=>:classic, :singular=>:singu102, :plural=>:plur103 }
    should_have_singleton_classics :singu101

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [ nil     ,:plur101], :provide=>:classic, :singular=>:singu102, :plural=>:plur103 }
    should_have_collec_classics    :singu102, :plur101 # :singular option is used; :plural is ignored.
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [ nil     ,:plur101], :provide=>:classic, :singular=>:singu102, :plural=>:plur103 }
    should_have_singleton_classics :singu102

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singu101, nil    ], :provide=>:classic, :singular=>:singu102, :plural=>:plur103 }
    should_have_collec_classics    :singu101, :plur103 # :singular is ignored; :plural is used.
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singu101, nil    ], :provide=>:classic, :singular=>:singu102, :plural=>:plur103 }
    should_have_singleton_classics :singu101

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singu101,:plur102], :provide=>:classic, :singular=>:singu103, :plural=>:plur104 }
    should_have_collec_classics    :singu101, :plur102 # :singular and :plural are both ignored.
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singu101,:plur102], :provide=>:classic, :singular=>:singu103, :plural=>:plur104 }
    should_have_singleton_classics :singu101
    end
  it "applies :controller option, to specify a controller name" do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :controller=>:acme }
    RT.all_route_ar.collect {|orig_r| r = orig_r.dup ; r[:controller] = 'acme' ; r }.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :controller=>:spumco }
    RT.s_all_route_ar.collect {|orig_r| r = orig_r.dup ; r[:controller] = 'spumco' ; r }.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :singu1 , :provide=>:classic, :controller=>:message }
    should_have_collec_classics    :singu1, :plur1, :controller=>'message'
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :singu1 , :provide=>:classic, :controller=>:message }
    should_have_singleton_classics :singu1,         :controller=>'message'

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :singu1 , :provide=>:classic, :controller=>:message }
    should_have_collec_classics    :singu1, :plur1, :controller=>'message'
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :singu1 , :provide=>:classic, :controller=>:message }
    should_have_singleton_classics :singu1,         :controller=>'message'

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources 'singu1', :provide=>:classic, :controller=>:message }
    should_have_collec_classics    :singu1, :plur1, :controller=>'message'
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  'singu1', :provide=>:classic, :controller=>:message }
    should_have_singleton_classics :singu1,         :controller=>'message'
    end
  it "applies the :plural_controllers option, to use whatever is the plural name" do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :singu1 , :provide=>:classic, :plural_controllers=>true }
    should_have_collec_classics    :singu1, :plur1, :controller=>'plur1'
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :singu2 , :provide=>:classic, :plural_controllers=>true }
    should_have_singleton_classics :singu2,         :controller=>'plur2'
    end
  it 'applies :as option, to specify a URL segment different from the resource name' do # ..resource() does not use ID fields.
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :as=>'as' }
    RT.all_route_ar.but_without(*RT.restful_c_u_d_ar).collect {|orig_r| r = orig_r.dup ; r[:path] = r[:path].gsub(/\/(singular|plural)/, '/as') ; r }.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :as=>'as' }
    RT.s_all_route_ar.collect {|orig_r| r = orig_r.dup ; r[:path] = r[:path].gsub(/\/singular/, '/as') ; r }.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic, :as=>'reviews' }
    should_have_collec_classics    :message, :messages, :as=>'reviews'
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic, :as=>'reviews' }
    should_have_singleton_classics :message,            :as=>'reviews'
    end
  it 'applies :path_prefix option, to prepend text to URL paths' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :path_prefix=>'/path_prefix/:path_prefix_id' }
    RT.all_route_ar.collect {|orig_r| r = orig_r.dup ; r[:path] = '/path_prefix/:path_prefix_id' + orig_r[:path] ; r }.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :path_prefix=>'/path_prefix/:path_prefix_id' }
    RT.s_all_route_ar.collect {|orig_r| r = orig_r.dup ; r[:path] = '/path_prefix/:path_prefix_id' + orig_r[:path] ; r }.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic, :path_prefix=>'thread/:thread_id' }
    should_have_collec_classics    :message, :messages, :path_prefix=>'thread/5/', :options=>{:thread_id=>'5'}
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic, :path_prefix=>'thread/:thread_id' }
    should_have_singleton_classics :message,            :path_prefix=>'thread/5/', :options=>{:thread_id=>'5'}

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :singu101, :provide=>:all, :path_prefix=>'/path_prefix/:path_prefix_id' }
    exp_route_ar = RT.all_route_ar.collect {|orig_r| r = orig_r.dup ; r[:path] = '/path_prefix/:path_prefix_id' + r[:path] ; r }
    exp_route_ar += exp_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101').gsub(/plural/,'plur101')
      r[:path] = r[:path].gsub(/\/singular/, '/singu101').gsub(/\/plural/,'/plur101')
      r[:controller] = 'singu101'
      r }
    exp_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :singu101, :provide=>:all, :path_prefix=>'/path_prefix/:path_prefix_id' }
    exp_route_ar = RT.s_all_route_ar.collect {|orig_r| r = orig_r.dup ; r[:path] = '/path_prefix/:path_prefix_id' + r[:path] ; r }
    exp_route_ar += exp_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101')
      r[:path] = r[:path].gsub(/\/singular/, '/singu101')
      r[:controller] = 'singu101'
      r }
    exp_route_ar.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], [:comment,:comments], :provide=>:classic, :path_prefix=>'/thread/:thread_id' }
    exp_route_ar = RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'message').gsub(/plural/,'messages')
      r[:path] = '/thread/:thread_id' + r[:path].gsub(/\/plural/,'/messages')
      r[:controller] = 'message'
      r }
    exp_route_ar += RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'comment').gsub(/plural/,'comments')
      r[:path] = '/thread/:thread_id' + r[:path].gsub(/\/plural/,'/comments')
      r[:controller] = 'comment'
      r }
    exp_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], [:comment,:comments], :provide=>:classic, :path_prefix=>'/thread/:thread_id' }
    exp_route_ar = RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'message')
      r[:path] = '/thread/:thread_id' + r[:path].gsub(/\/singular/,'/message')
      r[:controller] = 'message'
      r }
    exp_route_ar += RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'comment')
      r[:path] = '/thread/:thread_id' + r[:path].gsub(/\/singular/,'/comment')
      r[:controller] = 'comment'
      r }
    exp_route_ar.should be_exact_routes
    end
  it 'applies :conditions=>{:subdomain=>..} option, to specify additional match condition' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :conditions=>{:subdomain=>'app'} }
    @scratch_routes.named_routes.routes[:plural].conditions[:subdomain].should == 'app'
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :conditions=>{:subdomain=>'app'} }
    @scratch_routes.named_routes.routes[:singular].conditions[:subdomain].should == 'app'

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic, :conditions=>{:subdomain=>'app'} }
    @scratch_routes.named_routes.routes[:messages].conditions[:subdomain].should == 'app'
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic, :conditions=>{:subdomain=>'app'} }
    @scratch_routes.named_routes.routes[:message].conditions[:subdomain].should == 'app'
    end
  it 'generates default routes which recognize "123xyz" as a valid id field' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all }
    expec_options = {:controller=>'singular',:action=>'show',:id=>'123xyz'}
    should_route('plural/123xyz', expec_options)
    should_recognize(expec_options, :path=>'singular/123xyz' ,:method=>:get)
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic }
    expec_options = {:controller=>'message',:action=>'show',:id=>'123xyz'}
    should_route('messages/123xyz', expec_options)
    end
  it 'by default, generates routes which correctly raise RoutingError for URLs with id "1.1.1"' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all }
    expec_options = {:controller=>'singular',:action=>'show',:id=>'1.1.1'}
    doing { should_recognize(expec_options, :path=>'plural/1.1.1'  , :method=>:get) }.should raise_error(ActionController::RoutingError)
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :message, :plural=>:messages, :provide=>:classic }
    expec_options = {:controller=>'message' ,:action=>'show',:id=>'1.1.1'}
    doing { should_recognize(expec_options, :path=>'messages/1.1.1', :method=>:get) }.should raise_error(ActionController::RoutingError)
    end
  it 'applies :requirements=>{:id=>/[0-9]\.[0-9]\.[0-9]/} option to accept 1.1.1 as an ID field' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :requirements=>{:id=>/[0-9]\.[0-9]\.[0-9]/} }
    expec_options = {:controller=>'singular',:action=>'show',:id=>'1.1.1'}
    should_recognize expec_options, :path=>'plural/1.1.1'  ,:method=>:get
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic, :requirements=>{:id=>/[0-9]\.[0-9]\.[0-9]/} }
    expec_options = {:controller=>'message',:action=>'show',:id=>'1.1.1'}
    should_recognize expec_options, :path=>'messages/1.1.1',:method=>:get
    end
  it 'applies :name_prefix option (prepend text to route names)' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :name_prefix=>'name_prefix_' }
    RT.all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'name_prefix_singular').gsub(/plural/,'name_prefix_plural')
      r }.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :name_prefix=>'name_prefix_' }
    RT.s_all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'name_prefix_singular')
      r }.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic, :name_prefix=>'post_' }
    should_have_collec_classics    :message, :messages, :name_prefix=>'post_'
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic, :name_prefix=>'post_' }
    should_have_singleton_classics :message,            :name_prefix=>'post_'
    end
  it 'applies :path_prefix and :requirements options together' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all,
      :path_prefix=>'/path_prefix/:path_prefix_id', :requirements=>{:path_prefix_id=>/[0-9]\.[0-9]\.[0-9]/} }
    expected_opts = {:controller=>'singular',:action=>'show',:path_prefix_id=>'3.4.5',:id=>'9'}
    should_recognize expected_opts, :path=>'path_prefix/3.4.5/plural/9'       , :method=>:get
    should_recognize expected_opts, :path=>'path_prefix/3.4.5/singular/9'     , :method=>:get
    should_recognize expected_opts, :path=>'path_prefix/3.4.5/singular/9/show', :method=>:get
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic,
      :path_prefix=>'/thread/:thread_id', :requirements=>{:thread_id=>/[0-9]\.[0-9]\.[0-9]/} }
    expected_opts = {:controller=>'message',:action=>'show',:thread_id=>'1.1.1',:id=>'1'}
    should_recognize expected_opts, :path=>'thread/1.1.1/messages/1', :method=>:get
    end
  it 'applies :path_prefix , :requirements , and :as options together' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all,
      :path_prefix=>'/path_prefix/:path_prefix_id', :requirements=>{:path_prefix_id=>/[0-9]\.[0-9]\.[0-9]/}, :as=>'as' }
    expected_opts = {:controller=>'singular',:action=>'show',:path_prefix_id=>'7.2.6',:id=>'5'}
    should_recognize expected_opts, :path=>'path_prefix/7.2.6/as/5'     , :method=>:get
    # /path_prefix/7.2.6/as/5 occurs twice. Only check it once.
    should_recognize expected_opts, :path=>'path_prefix/7.2.6/as/5/show', :method=>:get
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all,
      :path_prefix=>'/path_prefix/:path_prefix_id', :requirements=>{:path_prefix_id=>/[0-9]\.[0-9]\.[0-9]/}, :as=>'as' }
    expected_opts = {:controller=>'singular',:action=>'show',:path_prefix_id=>'7.2.6'         }
    should_recognize expected_opts, :path=>'path_prefix/7.2.6/as'       , :method=>:get
    should_recognize expected_opts, :path=>'path_prefix/7.2.6/as/show'  , :method=>:get

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic,
      :path_prefix=>'/thread/:thread_id', :requirements=>{:thread_id=>/[0-9]\.[0-9]\.[0-9]/}, :as=>'comment' }
    expected_opts = {:controller=>'message',:action=>'show',:thread_id=>'1.1.1',:id=>'1'}
    should_recognize expected_opts, :path=>'thread/1.1.1/comment/1' , :method=>:get
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic,
      :path_prefix=>'/thread/:thread_id', :requirements=>{:thread_id=>/[0-9]\.[0-9]\.[0-9]/}, :as=>'comment' }
    expected_opts = {:controller=>'message',:action=>'show',:thread_id=>'1.1.1'         }
    should_recognize expected_opts, :path=>'thread/1.1.1/comment'   , :method=>:get
    end
  it 'applies :collection=>{..=>:get,..=>:post,..=>:put,..=>:delete} option, to add extra routes' do
    verb_keyed_by_action = {'a'=>:get,'b'=>:post,'c'=>:put,'d'=>:delete}
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :collection=>verb_keyed_by_action }
    exp_route_ar  = Array.new(RT.classic_route_ar).insert_above(RT.classic_index, nil,nil,nil,nil)
    exp_route_ar += Array.new(RT.pretty_plus_restful_route_ar).insert_above(RT.restful_index, nil,nil,nil,nil)
    exp_route_ar.should be_exact_routes
    [ { :name=>  'a_plural' , :verb=>'GET'   ,:path=>"/plural/a(.:format)"   ,:action=>'a' ,:controller=>'singular' },
      { :name=>  'b_plural' , :verb=>'POST'  ,:path=>"/plural/b(.:format)"   ,:action=>'b' ,:controller=>'singular' },
      { :name=>  'c_plural' , :verb=>'PUT'   ,:path=>"/plural/c(.:format)"   ,:action=>'c' ,:controller=>'singular' },
      { :name=>  'd_plural' , :verb=>'DELETE',:path=>"/plural/d(.:format)"   ,:action=>'d' ,:controller=>'singular' },
      { :name=>'singular_a' , :verb=>'GET'   ,:path=>"/singular/a(.:format)" ,:action=>'a' ,:controller=>'singular' },
      { :name=>'singular_b' , :verb=>'POST'  ,:path=>"/singular/b(.:format)" ,:action=>'b' ,:controller=>'singular' },
      { :name=>'singular_c' , :verb=>'PUT'   ,:path=>"/singular/c(.:format)" ,:action=>'c' ,:controller=>'singular' },
      { :name=>'singular_d' , :verb=>'DELETE',:path=>"/singular/d(.:format)" ,:action=>'d' ,:controller=>'singular' }
      ].should be_assorted_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :collection=>verb_keyed_by_action }
    exp_route_ar = Array.new(RT.s_classic_route_ar).insert_above(RT.s_classic_show, nil,nil,nil,nil)
    exp_route_ar += RT.s_pretty_plus_restful_route_ar.but_without(*RT.s_restful_c_u_d_ar).insert_above(RT.s_restful_show, nil,nil,nil,nil)
    exp_route_ar.should be_exact_routes
    [ { :name=>'a_singular' ,:verb=>'GET'   ,:path=>"/singular/a(.:format)" ,:action=>'a' ,:controller=>'singular' },
      { :name=>'b_singular' ,:verb=>'POST'  ,:path=>"/singular/b(.:format)" ,:action=>'b' ,:controller=>'singular' },
      { :name=>'c_singular' ,:verb=>'PUT'   ,:path=>"/singular/c(.:format)" ,:action=>'c' ,:controller=>'singular' },
      { :name=>'d_singular' ,:verb=>'DELETE',:path=>"/singular/d(.:format)" ,:action=>'d' ,:controller=>'singular' },
      { :name=>'singular_a' ,:verb=>'GET'   ,:path=>"/singular/a(.:format)" ,:action=>'a' ,:controller=>'singular' },
      { :name=>'singular_b' ,:verb=>'POST'  ,:path=>"/singular/b(.:format)" ,:action=>'b' ,:controller=>'singular' },
      { :name=>'singular_c' ,:verb=>'PUT'   ,:path=>"/singular/c(.:format)" ,:action=>'c' ,:controller=>'singular' },
      { :name=>'singular_d' ,:verb=>'DELETE',:path=>"/singular/d(.:format)" ,:action=>'d' ,:controller=>'singular' }
      ].should be_assorted_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic, :collection=>verb_keyed_by_action }
    should_have_collec_refer_classics    :message, :messages do |options|
      verb_keyed_by_action.each_pair do |action, verb|
        should_recognize options.merge(:action=>action), :path=>"/messages/#{action}", :method=>verb
      end ; end
    should_have_collec_named_classics    :message, :messages do |options|
      verb_keyed_by_action.each_key do |action|
        should_be_named_route "/messages/#{action}", "#{action}_messages", :action=>action
      end ; end
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic, :collection=>verb_keyed_by_action }
    should_have_singleton_refer_classics :message            do |options|
      verb_keyed_by_action.each_pair do |action, verb|
        should_recognize options.merge(:action=>action), :path=>"/message/#{action}" , :method=>verb
      end ; end
    should_have_singleton_named_classics :message            do |options|
      verb_keyed_by_action.each_key do |action|
        should_be_named_route "/message/#{action}" , "#{action}_message" , :action=>action
    end ; end ; end
  it 'applies :collection , :path_prefix , and :name_prefix options together' do
    verb_keyed_by_action = {'a'=>:get,'b'=>:post,'c'=>:put,'d'=>:delete}
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all,
      :collection=>verb_keyed_by_action, :path_prefix=>'/path_prefix/:path_prefix_id', :name_prefix=>'name_prefix_' }
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      unless r[:name].blank?
        r[:name] = ( r[:name] =~ /^(new_|edit_)/ ? r[:name].sub(/(new_|edit_)/, "#{$1}name_prefix_") : "name_prefix_#{r[:name]}" )
        end
      r[:path] = "/path_prefix/:path_prefix_id#{r[:path]}"
      r }.should be_assorted_routes
    [ { :name=>'a_name_prefix_plural' ,:verb=>'GET'   ,:path=>"/path_prefix/:path_prefix_id/plural/a(.:format)" ,:action=>'a' ,:controller=>'singular' },
      { :name=>'b_name_prefix_plural' ,:verb=>'POST'  ,:path=>"/path_prefix/:path_prefix_id/plural/b(.:format)" ,:action=>'b' ,:controller=>'singular' },
      { :name=>'c_name_prefix_plural' ,:verb=>'PUT'   ,:path=>"/path_prefix/:path_prefix_id/plural/c(.:format)" ,:action=>'c' ,:controller=>'singular' },
      { :name=>'d_name_prefix_plural' ,:verb=>'DELETE',:path=>"/path_prefix/:path_prefix_id/plural/d(.:format)" ,:action=>'d' ,:controller=>'singular' }
      ].should be_assorted_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = "name_prefix_#{r[:name]}" unless r[:name].blank?
      r[:path] = "/path_prefix/:path_prefix_id#{r[:path]}"
      r }.should be_assorted_routes
    [ { :name=>'name_prefix_singular_a' ,:verb=>'GET'   ,:path=>"/path_prefix/:path_prefix_id/singular/a(.:format)" ,:action=>'a' ,:controller=>'singular' },
      { :name=>'name_prefix_singular_b' ,:verb=>'POST'  ,:path=>"/path_prefix/:path_prefix_id/singular/b(.:format)" ,:action=>'b' ,:controller=>'singular' },
      { :name=>'name_prefix_singular_c' ,:verb=>'PUT'   ,:path=>"/path_prefix/:path_prefix_id/singular/c(.:format)" ,:action=>'c' ,:controller=>'singular' },
      { :name=>'name_prefix_singular_d' ,:verb=>'DELETE',:path=>"/path_prefix/:path_prefix_id/singular/d(.:format)" ,:action=>'d' ,:controller=>'singular' }
      ].should be_assorted_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all,
      :collection=>verb_keyed_by_action, :path_prefix=>'/path_prefix/:path_prefix_id', :name_prefix=>'name_prefix_' }
    RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      unless r[:name].blank?
        r[:name] = ( r[:name] =~ /^(new_|edit_)/ ? r[:name].sub(/(new_|edit_)/, "#{$1}name_prefix_") : "name_prefix_#{r[:name]}" )
        end
      r[:path] = "/path_prefix/:path_prefix_id#{r[:path]}"
      r }.should be_assorted_routes
    [ { :name=>'a_name_prefix_singular' ,:verb=>'GET'   ,:path=>"/path_prefix/:path_prefix_id/singular/a(.:format)",:action=>'a' ,:controller=>'singular' },
      { :name=>'b_name_prefix_singular' ,:verb=>'POST'  ,:path=>"/path_prefix/:path_prefix_id/singular/b(.:format)",:action=>'b' ,:controller=>'singular' },
      { :name=>'c_name_prefix_singular' ,:verb=>'PUT'   ,:path=>"/path_prefix/:path_prefix_id/singular/c(.:format)",:action=>'c' ,:controller=>'singular' },
      { :name=>'d_name_prefix_singular' ,:verb=>'DELETE',:path=>"/path_prefix/:path_prefix_id/singular/d(.:format)",:action=>'d' ,:controller=>'singular' }
      ].should be_assorted_routes
    RT.s_pretty_plus_restful_route_ar.but_without(*RT.s_restful_c_u_d_ar).collect {|orig_r| r = orig_r.dup
      r[:name] = "name_prefix_#{r[:name]}" unless r[:name].blank?
      r[:path] = "/path_prefix/:path_prefix_id#{r[:path]}"
      r }.should be_assorted_routes
    [ { :name=>'name_prefix_singular_a' ,:verb=>'GET'   ,:path=>"/path_prefix/:path_prefix_id/singular/a(.:format)" ,:action=>'a' ,:controller=>'singular' },
      { :name=>'name_prefix_singular_b' ,:verb=>'POST'  ,:path=>"/path_prefix/:path_prefix_id/singular/b(.:format)" ,:action=>'b' ,:controller=>'singular' },
      { :name=>'name_prefix_singular_c' ,:verb=>'PUT'   ,:path=>"/path_prefix/:path_prefix_id/singular/c(.:format)" ,:action=>'c' ,:controller=>'singular' },
      { :name=>'name_prefix_singular_d' ,:verb=>'DELETE',:path=>"/path_prefix/:path_prefix_id/singular/d(.:format)" ,:action=>'d' ,:controller=>'singular' }
      ].should be_assorted_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic,
      :collection=>verb_keyed_by_action, :path_prefix=>'/threads/:thread_id', :name_prefix=>'thread_' }
    should_have_collec_refer_classics    :message, :messages, :path_prefix=>'threads/1/', :name_prefix=>'thread_', :options=>{:thread_id=>'1'} do |options|
      verb_keyed_by_action.each do |action, verb|
        should_recognize options.merge(:action=>action               ), :path=>"/threads/1/messages/#{action}"    , :method=>verb
        should_recognize options.merge(:action=>action,:format=>'xml'), :path=>"/threads/1/messages/#{action}.xml", :method=>verb
      end ; end
    should_have_collec_named_classics    :message, :messages, :path_prefix=>'threads/1/', :name_prefix=>'thread_', :options=>{:thread_id=>'1'} do |options|
      verb_keyed_by_action.keys.each do |action|
        should_be_named_route "/threads/1/messages/#{action}"    , "#{action}_thread_messages", :action=>action
        should_be_named_route "/threads/1/messages/#{action}.xml", "#{action}_thread_messages", :action=>action, :format=>'xml'
      end ; end
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic,
      :collection=>verb_keyed_by_action, :path_prefix=>'/threads/:thread_id', :name_prefix=>'thread_' }
    should_have_singleton_refer_classics :message,            :path_prefix=>'threads/1/', :name_prefix=>'thread_', :options=>{:thread_id=>'1'} do |options|
      verb_keyed_by_action.each do |action, verb|
        should_recognize options.merge(:action=>action               ), :path=>"/threads/1/message/#{action}"     , :method=>verb
        should_recognize options.merge(:action=>action,:format=>'xml'), :path=>"/threads/1/message/#{action}.xml" , :method=>verb
      end ; end
    should_have_singleton_named_classics :message,            :path_prefix=>'threads/1/', :name_prefix=>'thread_', :options=>{:thread_id=>'1'} do |options|
      verb_keyed_by_action.keys.each do |action|
        should_be_named_route "/threads/1/messages/#{action}"    , "#{action}_thread_message" , :action=>action
        should_be_named_route "/threads/1/messages/#{action}.xml", "#{action}_thread_message" , :action=>action, :format=>'xml'
    end ; end ; end
  it 'correctly raises ArgumentError when given a :member=>{..=>( bad verb )} option' do
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :x                  ,  :provide=>:all    , :member=>{:anything =>:head   } } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :x                  ,  :provide=>:all    , :member=>{:anything =>:head   } } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :x                  ,  :provide=>:all    , :member=>{:something=>:badverb} } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :x                  ,  :provide=>:all    , :member=>{:something=>:badverb} } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages],  :provide=>:classic, :member=>{:something=>:head   } } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages],  :provide=>:classic, :member=>{:something=>:head   } } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages],  :provide=>:classic, :member=>{:anything =>:badverb} } }.should raise_error(ArgumentError)
    doing { @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages],  :provide=>:classic, :member=>{:anything =>:badverb} } }.should raise_error(ArgumentError)
    end
  [:post,:put].each do |verb|
    it "applies :member=>{..=>#{verb.inspect}} option, to specify additional Member actions for #{verb.to_s.upcase}" do
      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :member=>{:z=>verb} }
      exp_route_ar = Array.new(RT.all_route_ar)
      exp_route_ar.insert_above(RT.classic_show, { :name=>'z_singular'    , :verb=>verb.to_s.upcase, :path=>'/plural/:id/z(.:format)'   , :action=>'z', :controller=>'singular' } )
      exp_route_ar.insert_above(RT.restful_show, { :name=>'singular_id_z' , :verb=>verb.to_s.upcase, :path=>'/singular/:id/z(.:format)' , :action=>'z', :controller=>'singular' } )
      exp_route_ar.should be_exact_routes
      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :member=>{:z=>verb} }
      exp_route_ar = Array.new(RT.s_all_route_ar)
      exp_route_ar.insert_above(RT.s_classic_show, { :name=>'z_singular' , :verb=>verb.to_s.upcase, :path=>'/singular/z(.:format)' , :action=>'z', :controller=>'singular' } )
      exp_route_ar.insert_above(RT.s_restful_show, { :name=>'singular_z' , :verb=>verb.to_s.upcase, :path=>'/singular/z(.:format)' , :action=>'z', :controller=>'singular' } )
      exp_route_ar.should be_exact_routes

      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic, :member=>{:mark=>verb} }
      mark_options = {:action=>'mark',:id=>'1'} ; mark_path = '/messages/1/mark'
      should_have_collec_refer_classics    :message, :messages do |options|
        should_recognize(options.merge(mark_options), :path=>mark_path, :method=>verb) ; end
      should_have_collec_named_classics    :message, :messages do |options|
        should_be_named_route mark_path, :mark_message, mark_options ; end
      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic, :member=>{:mark=>verb} }
      mark_options = {:action=>'mark'         } ; mark_path = '/message/mark'
      should_have_singleton_refer_classics :message            do |options|
        should_recognize(options.merge(mark_options), :path=>mark_path, :method=>verb) ; end
      should_have_singleton_named_classics :message            do |options|
        should_be_named_route mark_path, :mark_message, mark_options ; end
    end ; end
  [:post,:put].each do |verb|
    it "applies :member=>{..=>#{verb.inspect}} and :path_names=>{:new=>'nuevo'} options together" do
      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :member=>{:z=>verb}, :path_names=>{:new=>'nuevo'} }
      exp_route_ar = RT.all_route_ar.collect {|orig_r| r = orig_r.dup
        r[:path] = r[:path].gsub(/\/new/,'/nuevo')
        r }
      exp_route_ar.insert_above(RT.classic_show, { :name=>'z_singular'   , :verb=>verb.to_s.upcase, :path=>'/plural/:id/z(.:format)'  , :action=>'z', :controller=>'singular' })
      exp_route_ar.insert_above(RT.restful_show, { :name=>'singular_id_z', :verb=>verb.to_s.upcase, :path=>'/singular/:id/z(.:format)', :action=>'z', :controller=>'singular' })
      exp_route_ar.should be_exact_routes
      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :member=>{:z=>verb}, :path_names=>{:new=>'nuevo'} }
      exp_route_ar = RT.s_all_route_ar.collect {|orig_r| r = orig_r.dup
        r[:path] = r[:path].gsub(/\/new/,'/nuevo')
        r }
      exp_route_ar.insert_above(RT.s_classic_show, { :name=>'z_singular' , :verb=>verb.to_s.upcase, :path=>'/singular/z(.:format)', :action=>'z', :controller=>'singular' })
      exp_route_ar.insert_above(RT.s_restful_show, { :name=>'singular_z' , :verb=>verb.to_s.upcase, :path=>'/singular/z(.:format)', :action=>'z', :controller=>'singular' })
      exp_route_ar.should be_exact_routes

      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic, :member=>{:mark=>verb}, :path_names=>{:new=>'nuevo'} }
      mark_path = '/messages/1/mark' ; mark_options = {:action=>'mark',:id=>'1',:controller=>'message'}
      should_have_collec_refer_classics    :message, :messages, :path_names=>{:new=>'nuevo'} do |options|
        should_recognize(options.merge(mark_options), :path=>mark_path, :method=>verb) ; end
      should_have_collec_named_classics    :message, :messages, :path_names=>{:new=>'nuevo'} do |options|
        should_be_named_route mark_path, :mark_message, mark_options ; end
      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic, :member=>{:mark=>verb}, :path_names=>{:new=>'nuevo'} }
      mark_path = '/message/mark'    ; mark_options = {:action=>'mark',         :controller=>'message'}
      should_have_singleton_refer_classics :message,            :path_names=>{:new=>'nuevo'} do |options|
        should_recognize(options.merge(mark_options), :path=>mark_path, :method=>verb) ; end
      should_have_singleton_named_classics :message,            :path_names=>{:new=>'nuevo'} do |options|
        should_be_named_route mark_path, :mark_message, mark_options ; end
    end ; end
  [:post,:put].each do |verb|
    it "accepts two member actions to the same HTTP #{verb.to_s.upcase} verb" do
      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :member=>{:z=>verb,:y=>verb} }
      exp_route_ar = Array.new(RT.all_route_ar)
      exp_route_ar.insert_above(RT.classic_show,nil,nil) # Classic y.. and z.. go here.
      exp_route_ar.insert_above(RT.restful_show,nil,nil) # Restful ..y and ..z go here.
      exp_route_ar.should be_exact_routes
      name_right = '_singular' ; path_left = '/plural/:id/'
      [ { :name=>"y#{name_right}", :verb=>verb.to_s.upcase, :path=>"#{path_left}y(.:format)", :action=>'y', :controller=>'singular' },
        { :name=>"z#{name_right}", :verb=>verb.to_s.upcase, :path=>"#{path_left}z(.:format)", :action=>'z', :controller=>'singular' }
        ].should be_assorted_routes # Since the :member option takes a hash, its sequence is undefined.
      name_left = 'singular_id_' ; path_left = '/singular/:id/'
      [ { :name=>"#{name_left}y" , :verb=>verb.to_s.upcase, :path=>"#{path_left}y(.:format)", :action=>'y', :controller=>'singular' },
        { :name=>"#{name_left}z" , :verb=>verb.to_s.upcase, :path=>"#{path_left}z(.:format)", :action=>'z', :controller=>'singular' }
        ].should be_assorted_routes
      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :member=>{:z=>verb,:y=>verb} }
      exp_route_ar = Array.new(RT.s_all_route_ar)
      exp_route_ar.insert_above(RT.s_classic_show,nil,nil) # Classic y.. and z.. go here.
      exp_route_ar.insert_above(RT.s_restful_show,nil,nil) # Restful ..y and ..z go here.
      exp_route_ar.should be_exact_routes
      name_right = '_singular' ; path_left = '/singular/'
      [ { :name=>"y#{name_right}", :verb=>verb.to_s.upcase, :path=>"#{path_left}y(.:format)", :action=>'y', :controller=>'singular' },
        { :name=>"z#{name_right}", :verb=>verb.to_s.upcase, :path=>"#{path_left}z(.:format)", :action=>'z', :controller=>'singular' }
        ].should be_assorted_routes # Since the :member option takes a hash, its sequence is undefined.
      name_left = 'singular_' ; path_left = '/singular/'
      [ { :name=>"#{name_left}y" , :verb=>verb.to_s.upcase, :path=>"#{path_left}y(.:format)", :action=>'y', :controller=>'singular' },
        { :name=>"#{name_left}z" , :verb=>verb.to_s.upcase, :path=>"#{path_left}z(.:format)", :action=>'z', :controller=>'singular' }
        ].should be_assorted_routes

      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic, :member=>{:mark=>verb,:unmark=>verb} }
      ['mark','unmark'].each do |action|
        action_path = "/messages/1/#{action}" ; action_options = {:action=>action,:id=>'1'}
        should_have_collec_refer_classics    :message, :messages do |options|
          should_recognize options.merge(action_options), :path=>action_path, :method=>verb ; end
        should_have_collec_named_classics    :message, :messages do |options|
          should_be_named_route action_path, "#{action}_message".to_sym, action_options ; end
        end
      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic, :member=>{:mark=>verb,:unmark=>verb} }
      ['mark','unmark'].each do |action|
        action_path = "/message/#{action}"    ; action_options = {:action=>action         }
        should_have_singleton_refer_classics :message            do |options|
          should_recognize options.merge(action_options), :path=>action_path, :method=>verb ; end
        should_have_singleton_named_classics :message            do |options|
          should_be_named_route action_path, "#{action}_message".to_sym, action_options ; end
        end
    end ; end
  it "accepts irregular id requirements for user-specified member actions" do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :member=>{:custom=>:get}, :requirements=>{:id=>/[0-9]\.[0-9]\.[0-9]/} }
    expec_options = {:controller=>'singular',:action=>'custom',:id=>'1.1.1'}
    should_recognize expec_options, :path=>'plural/1.1.1/custom' ,:method=>:get
    end
  it 'understands arrays (or :any) supplied to action keys specified in the :collection and :member options' do
    # In outlaw_resource() :collection and :member both behave as if they were :member (no :id field).
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :collection=>{:a=>[:get,:post]}, :member=>{:z=>[:post,:get]} }
    exp_route_ar = Array.new(RT.all_route_ar)
    exp_route_ar.insert_above(RT.classic_index,nil,nil) # Classic a.. routes
    exp_route_ar.insert_above(RT.classic_show ,nil,nil) # Classic z.. routes
    exp_route_ar.insert_above(RT.restful_index,nil,nil) # RESTful a.. routes
    exp_route_ar.insert_above(RT.restful_show ,nil,nil) # RESTful z.. routes
    exp_route_ar.should be_exact_routes
    [ { :name=>          ""   , :verb=>'POST', :path=>"/plural/a(.:format)"      , :action=>'a', :controller=>'singular' },
      { :name=>  "a_plural"   , :verb=>'GET' , :path=>"/plural/a(.:format)"      , :action=>'a', :controller=>'singular' },
      { :name=>          ""   , :verb=>'POST', :path=>"/plural/:id/z(.:format)"  , :action=>'z', :controller=>'singular' },
      { :name=>"z_singular"   , :verb=>'GET' , :path=>"/plural/:id/z(.:format)"  , :action=>'z', :controller=>'singular' },
      { :name=>"singular_a"   , :verb=>'GET' , :path=>"/singular/a(.:format)"    , :action=>'a', :controller=>'singular' },
      { :name=>""             , :verb=>'POST', :path=>"/singular/a(.:format)"    , :action=>'a', :controller=>'singular' },
      { :name=>"singular_id_z", :verb=>'GET' , :path=>"/singular/:id/z(.:format)", :action=>'z', :controller=>'singular' },
      { :name=>""             , :verb=>'POST', :path=>"/singular/:id/z(.:format)", :action=>'z', :controller=>'singular' }
      ].should be_assorted_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :collection=>{:a=>[:get,:post]}, :member=>{:z=>[:post,:get]} }
    exp_route_ar = Array.new(RT.s_all_route_ar)
    exp_route_ar.insert_above(RT.s_classic_show,nil,nil,nil,nil) # For a singleton resource, :collection is combined into :member .
    exp_route_ar.insert_above(RT.s_restful_show,nil,nil)         # Same here, but the two anonymous routes ore identical to others.
    exp_route_ar.should be_exact_routes
    [ { :name=>          "", :verb=>'POST', :path=>"/singular/a(.:format)", :action=>'a', :controller=>'singular' },
      { :name=>"a_singular", :verb=>'GET' , :path=>"/singular/a(.:format)", :action=>'a', :controller=>'singular' },
      { :name=>          "", :verb=>'POST', :path=>"/singular/z(.:format)", :action=>'z', :controller=>'singular' },
      { :name=>"z_singular", :verb=>'GET' , :path=>"/singular/z(.:format)", :action=>'z', :controller=>'singular' },
      { :name=>"singular_a", :verb=>'GET' , :path=>"/singular/a(.:format)", :action=>'a', :controller=>'singular' },
      { :name=>""          , :verb=>'POST', :path=>"/singular/a(.:format)", :action=>'a', :controller=>'singular' },
      { :name=>"singular_z", :verb=>'GET' , :path=>"/singular/z(.:format)", :action=>'z', :controller=>'singular' },
      { :name=>""          , :verb=>'POST', :path=>"/singular/z(.:format)", :action=>'z', :controller=>'singular' }
      ].should be_assorted_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic, :collection=>{:search=>:any}, :member=>{:toggle=>:any} }
    should_have_collec_refer_classics    :message, :messages do |options|
      [:get,:post,:put,:delete].each {|verb| should_recognize options.merge(:action=>'search'         ), :path=>'/messages/search'  , :method=>verb }
      [:get,:post,:put,:delete].each {|verb| should_recognize options.merge(:action=>'toggle',:id=>'1'), :path=>'/messages/1/toggle', :method=>verb }
      end
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic, :collection=>{:search=>:any}, :member=>{:toggle=>:any} }
    should_have_singleton_refer_classics :message            do |options|
      [:get,:post,:put,:delete].each {|verb| should_recognize options.merge(:action=>'search'         ), :path=>'/message/search'   , :method=>verb }
      [:get,:post,:put,:delete].each {|verb| should_recognize options.merge(:action=>'toggle'         ), :path=>'/message/toggle'   , :method=>verb }
      end
    end
  it 'applies :new=>{..=>:any} option, to route all HTTP verbs to additional New actions' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :new=>{:n=>:any} }
    doing { ActionController::Routing::Routes.recognize_path('/plural/new/n'  ,:method=>:get   ) }.should_not raise_error
    doing { ActionController::Routing::Routes.recognize_path('/plural/new/n'  ,:method=>:post  ) }.should_not raise_error
    doing { ActionController::Routing::Routes.recognize_path('/plural/new/n'  ,:method=>:put   ) }.should_not raise_error
    doing { ActionController::Routing::Routes.recognize_path('/plural/new/n'  ,:method=>:delete) }.should_not raise_error
    doing { ActionController::Routing::Routes.recognize_path('/singular/new/n',:method=>:get   ) }.should_not raise_error
    doing { ActionController::Routing::Routes.recognize_path('/singular/new/n',:method=>:post  ) }.should_not raise_error
    doing { ActionController::Routing::Routes.recognize_path('/singular/new/n',:method=>:put   ) }.should_not raise_error
    doing { ActionController::Routing::Routes.recognize_path('/singular/new/n',:method=>:delete) }.should_not raise_error
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :new=>{:n=>:any} }
    doing { ActionController::Routing::Routes.recognize_path('/plural/new/n'  ,:method=>:get   ) }.should raise_error(ActionController::RoutingError)
    doing { ActionController::Routing::Routes.recognize_path('/plural/new/n'  ,:method=>:post  ) }.should raise_error(ActionController::RoutingError)
    doing { ActionController::Routing::Routes.recognize_path('/plural/new/n'  ,:method=>:put   ) }.should raise_error(ActionController::RoutingError)
    doing { ActionController::Routing::Routes.recognize_path('/plural/new/n'  ,:method=>:delete) }.should raise_error(ActionController::RoutingError)
    doing { ActionController::Routing::Routes.recognize_path('/singular/new/n',:method=>:get   ) }.should_not raise_error
    doing { ActionController::Routing::Routes.recognize_path('/singular/new/n',:method=>:post  ) }.should_not raise_error
    doing { ActionController::Routing::Routes.recognize_path('/singular/new/n',:method=>:put   ) }.should_not raise_error
    doing { ActionController::Routing::Routes.recognize_path('/singular/new/n',:method=>:delete) }.should_not raise_error

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic, :new=>{:new=>:any} }
    should_have_collec_refer_classics    :message, :messages do |options|
      should_recognize options.merge(:action=>'new'), :path=>'/messages/new', :method=>:get
      should_recognize options.merge(:action=>'new'), :path=>'/messages/new', :method=>:post
      end
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic, :new=>{:new=>:any} }
    should_have_singleton_refer_classics :message            do |options|
      should_recognize options.merge(:action=>'new'), :path=>'/message/new' , :method=>:get
      should_recognize options.merge(:action=>'new'), :path=>'/message/new' , :method=>:post
      end
    end
  it 'applies :new=>{..=>:post} option to route HTTP POST to additional New actions' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :new=>{:n=>:post} }
    exp_route_ar = Array.new(RT.all_route_ar)
    exp_route_ar.insert_above(RT.classic_show,nil).insert_above(RT.pretty_create,nil).nil_out_at(RT.classic_new, RT.restful_new)
    exp_route_ar.should be_exact_routes
    [ { :name=>  "new_singular", :verb=>'GET' , :path=>"/plural/new(.:format)"    , :action=>'new', :controller=>'singular' },
      { :name=>"n_new_singular", :verb=>'POST', :path=>"/plural/new/n(.:format)"  , :action=>'n'  , :controller=>'singular' },
      { :name=>"singular_new"  , :verb=>'GET' , :path=>"/singular/new(.:format)"  , :action=>'new', :controller=>'singular' },
      { :name=>"singular_new_n", :verb=>'POST', :path=>"/singular/new/n(.:format)", :action=>'n'  , :controller=>'singular' }
      ].should be_assorted_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :new=>{:n=>:post} }
    exp_route_ar = Array.new(RT.s_all_route_ar)
    exp_route_ar.insert_above(RT.s_classic_show,nil).insert_above(RT.s_pretty_create,nil).nil_out_at(RT.s_classic_new,RT.s_restful_new)
    exp_route_ar.should be_exact_routes
    [ { :name=>  "new_singular", :verb=>'GET' , :path=>"/singular/new(.:format)"  , :action=>'new', :controller=>'singular' },
      { :name=>"n_new_singular", :verb=>'POST', :path=>"/singular/new/n(.:format)", :action=>'n'  , :controller=>'singular' },
      { :name=>"singular_new"  , :verb=>'GET' , :path=>"/singular/new(.:format)"  , :action=>'new', :controller=>'singular' },
      { :name=>"singular_new_n", :verb=>'POST', :path=>"/singular/new/n(.:format)", :action=>'n'  , :controller=>'singular' }
      ].should be_assorted_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic, :new=>{:preview=>:post} }
    preview_path = '/messages/new/preview' ; preview_options = {:action=>'preview'}
    should_have_collec_refer_classics    :message, :messages do |options|
      should_recognize options.merge(preview_options), :path=>preview_path, :method=>:post ; end
    should_have_collec_named_classics    :message, :messages do |options|
      should_be_named_route preview_path, :preview_new_message, preview_options ; end
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic, :new=>{:preview=>:post} }
    preview_path = '/message/new/preview'  ; preview_options = {:action=>'preview'}
    should_have_singleton_refer_classics :message            do |options|
      should_recognize options.merge(preview_options), :path=>preview_path, :method=>:post ; end
    should_have_singleton_named_classics :message            do |options|
      should_be_named_route preview_path, :preview_new_message, preview_options ; end
    end
  it 'applies :name_prefix , :path_prefix , and :new=>{..=>:post} options together' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :new=>{:n=>:post}, :path_prefix=>'/path_prefix/:path_prefix_id', :name_prefix=>'name_prefix_' }
    exp_route_ar = Array.new(RT.all_route_ar)
    exp_route_ar.insert_above(RT.classic_show,nil).insert_above(RT.pretty_create,nil).nil_out_at(RT.classic_new,RT.restful_new)
    exp_route_ar = exp_route_ar.collect {|orig_r| next if orig_r.nil?
      r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'name_prefix_singular').gsub(/plural/,'name_prefix_plural')
      r[:path] = "/path_prefix/:path_prefix_id#{r[:path]}"
      r }
    exp_route_ar.should be_exact_routes
    [ { :name=>  "new_name_prefix_singular", :verb=>'GET' , :path=>"/path_prefix/:path_prefix_id/plural/new(.:format)"    , :action=>'new', :controller=>'singular' },
      { :name=>"n_new_name_prefix_singular", :verb=>'POST', :path=>"/path_prefix/:path_prefix_id/plural/new/n(.:format)"  , :action=>'n'  , :controller=>'singular' },
      { :name=>"name_prefix_singular_new"  , :verb=>'GET' , :path=>"/path_prefix/:path_prefix_id/singular/new(.:format)"  , :action=>'new', :controller=>'singular' },
      { :name=>"name_prefix_singular_new_n", :verb=>'POST', :path=>"/path_prefix/:path_prefix_id/singular/new/n(.:format)", :action=>'n'  , :controller=>'singular' }
      ].should be_assorted_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :new=>{:n=>:post}, :path_prefix=>'/path_prefix/:path_prefix_id', :name_prefix=>'name_prefix_' }
    exp_route_ar = Array.new(RT.s_all_route_ar)
    exp_route_ar.insert_above(RT.s_classic_show,nil).insert_above(RT.s_pretty_create,nil).nil_out_at(RT.s_classic_new,RT.s_restful_new)
    exp_route_ar = exp_route_ar.collect {|orig_r| next if orig_r.nil?
      r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'name_prefix_singular')
      r[:path] = "/path_prefix/:path_prefix_id#{r[:path]}"
      r }
    exp_route_ar.should be_exact_routes
    [ { :name=>  "new_name_prefix_singular", :verb=>'GET' , :path=>"/path_prefix/:path_prefix_id/singular/new(.:format)"  , :action=>'new', :controller=>'singular' },
      { :name=>"n_new_name_prefix_singular", :verb=>'POST', :path=>"/path_prefix/:path_prefix_id/singular/new/n(.:format)", :action=>'n'  , :controller=>'singular' },
      { :name=>"name_prefix_singular_new"  , :verb=>'GET' , :path=>"/path_prefix/:path_prefix_id/singular/new(.:format)"  , :action=>'new', :controller=>'singular' },
      { :name=>"name_prefix_singular_new_n", :verb=>'POST', :path=>"/path_prefix/:path_prefix_id/singular/new/n(.:format)", :action=>'n'  , :controller=>'singular' }
      ].should be_assorted_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic, :new=>{:preview=>:post}, :path_prefix=>'/threads/:thread_id', :name_prefix=>'thread_' }
    preview_path = '/threads/1/messages/new/preview' ; preview_options = {:action=>'preview', :thread_id=>'1'}
    should_have_collec_refer_classics    :message, :messages, :path_prefix=>'threads/1/', :name_prefix=>'thread_', :options=>{:thread_id=>'1'} do |options|
      should_recognize options.merge(preview_options)                      , :path=>preview_path         , :method=>:post
      should_recognize options.merge(preview_options).merge(:format=>'xml'), :path=>"#{preview_path}.xml", :method=>:post
      end
    should_have_collec_named_classics    :message, :messages, :path_prefix=>'threads/1/', :name_prefix=>'thread_', :options=>{:thread_id=>'1'} do |options|
      should_be_named_route preview_path         , :preview_new_thread_message, preview_options
      should_be_named_route "#{preview_path}.xml", :preview_new_thread_message, preview_options.merge(:format=>'xml')
      end
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic, :new=>{:preview=>:post}, :path_prefix=>'/threads/:thread_id', :name_prefix=>'thread_' }
    preview_path = '/threads/1/message/new/preview'  ; preview_options = {:action=>'preview', :thread_id=>'1'}
    should_have_singleton_refer_classics :message, :path_prefix=>'threads/1/', :name_prefix=>'thread_', :options=>{:thread_id=>'1'} do |options|
      should_recognize options.merge(preview_options)                      , :path=>preview_path         , :method=>:post
      should_recognize options.merge(preview_options).merge(:format=>'xml'), :path=>"#{preview_path}.xml", :method=>:post
      end
    should_have_singleton_named_classics :message, :path_prefix=>'threads/1/', :name_prefix=>'thread_', :options=>{:thread_id=>'1'} do |options|
      should_be_named_route preview_path         , :preview_new_thread_message, preview_options
      should_be_named_route "#{preview_path}.xml", :preview_new_thread_message, preview_options.merge(:format=>'xml')
      end
    end
  it 'applies :name_prefix , :path_prefix , :collection , and :new options together' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all,
      :name_prefix=>'thread_', :path_prefix=>'thread/:thread_id', :collection=>{:search=>:get}, :new=>{:preview=>:any} }
    exp_route_ar = Array.new(RT.all_route_ar)
    exp_route_ar.insert_above(RT.classic_index, { :name=>"search_plural"                   , :verb=>'GET', :path=>"/plural/search(.:format)"       , :action=>'search' , :controller=>'singular' })
    exp_route_ar.insert_above(RT.classic_show , { :name=>"preview_new_singular"            , :verb=>''   , :path=>"/plural/new/preview(.:format)"  , :action=>'preview', :controller=>'singular' })
    exp_route_ar.insert_above(RT.restful_index, { :name=>"singular_search"                 , :verb=>'GET', :path=>"/singular/search(.:format)"     , :action=>'search' , :controller=>'singular' })
    exp_route_ar.insert_above(RT.pretty_create, { :name=>"singular_new_preview"            , :verb=>''   , :path=>"/singular/new/preview(.:format)", :action=>'preview', :controller=>'singular' })
    exp_route_ar.collect! {|orig_r| next if orig_r.nil?
      r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'thread_singular').gsub(/plural/,'thread_plural')
      r[:path] = "/thread/:thread_id#{r[:path]}"
      r }
    exp_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all,
      :name_prefix=>'thread_', :path_prefix=>'thread/:thread_id', :collection=>{:search=>:get}, :new=>{:preview=>:any} }
    exp_route_ar = Array.new(RT.s_all_route_ar)
    exp_route_ar.insert_above(RT.s_classic_show ,
      { :name=>"preview_new_singular" , :verb=>''   , :path=>"/singular/new/preview(.:format)", :action=>'preview', :controller=>'singular' },
      { :name=>"search_singular"      , :verb=>'GET', :path=>"/singular/search(.:format)"     , :action=>'search' , :controller=>'singular' })
    exp_route_ar.insert_above(RT.s_restful_show ,
      { :name=>"singular_search"      , :verb=>'GET', :path=>"/singular/search(.:format)"     , :action=>'search' , :controller=>'singular' })
    exp_route_ar.insert_above(RT.s_pretty_create,
      { :name=>"singular_new_preview" , :verb=>''   , :path=>"/singular/new/preview(.:format)", :action=>'preview', :controller=>'singular' })
    exp_route_ar.collect! {|orig_r| next if orig_r.nil?
      r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'thread_singular')
      r[:path] = "/thread/:thread_id#{r[:path]}"
      r }
    exp_route_ar.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic,
      :name_prefix=>'thread_', :path_prefix=>'threads/:thread_id', :collection=>{:search=>:get}, :new=>{:preview=>:any} }
    should_have_collec_classics    :message, :messages, :name_prefix=>'thread_', :path_prefix=>'threads/1/', :options=>{:thread_id=>'1'}
    should_be_named_route '/threads/1/messages/search'     ,'search_thread_messages'
    should_be_named_route '/threads/1/messages/new'        ,'new_thread_message'
    should_be_named_route '/threads/1/messages/new/preview','preview_new_thread_message'
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic,
      :name_prefix=>'thread_', :path_prefix=>'threads/:thread_id', :collection=>{:search=>:get}, :new=>{:preview=>:any} }
    should_have_singleton_classics :message,            :name_prefix=>'thread_', :path_prefix=>'threads/1/', :options=>{:thread_id=>'1'}
    should_be_named_route '/threads/1/message/search'      ,'search_thread_message'
    should_be_named_route '/threads/1/message/new'         ,'new_thread_message'
    should_be_named_route '/threads/1/message/new/preview' ,'preview_new_thread_message'
    end
  it 'applies :name_prefix , :path_prefix , :member=>{..}, :new=>{..} options together' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:account,:accounts], :provide=>:all,
      :name_prefix=>'admin_', :path_prefix=>'admin', :member=>{:login=>:get}, :new=>{:preview=>:any} }
    exp_route_ar = Array.new(RT.all_route_ar)
    exp_route_ar.insert_above(RT.classic_show ,nil,nil)
    exp_route_ar.insert_above(RT.pretty_create,nil)
    exp_route_ar.insert_above(RT.restful_show ,nil)
    exp_route_ar.collect! {|orig_r| next if orig_r.nil?
      r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'admin_account').gsub(/plural/,'admin_accounts')
      r[:path] = "/admin#{r[:path]}".gsub(/singular/,'account').gsub(/plural/,'accounts')
      r[:controller] = 'account'
      r }
    exp_route_ar.should be_exact_routes
    [ { :name=>"preview_new_admin_account", :verb=>''   , :path=>"/admin/accounts/new/preview(.:format)", :action=>'preview', :controller=>'account' },
      { :name=>      "login_admin_account", :verb=>'GET', :path=>"/admin/accounts/:id/login(.:format)"  , :action=>'login'  , :controller=>'account' },
      { :name=>"admin_account_new_preview", :verb=>''   , :path=>"/admin/account/new/preview(.:format)" , :action=>'preview', :controller=>'account' },
      { :name=>"admin_account_id_login"   , :verb=>'GET', :path=>"/admin/account/:id/login(.:format)"   , :action=>'login'  , :controller=>'account' }
      ].should be_assorted_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:account,:accounts], :provide=>:all,
      :name_prefix=>'admin_', :path_prefix=>'admin', :member=>{:login=>:get}, :new=>{:preview=>:any} }
    exp_route_ar = Array.new(RT.s_all_route_ar)
    exp_route_ar.insert_above(RT.s_classic_show ,nil,nil)
    exp_route_ar.insert_above(RT.s_pretty_create,nil)
    exp_route_ar.insert_above(RT.s_restful_show ,nil)
    exp_route_ar.collect! {|orig_r| next if orig_r.nil?
      r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'admin_account')
      r[:path] = "/admin#{r[:path]}".gsub(/singular/,'account')
      r[:controller] = 'account'
      r }
    exp_route_ar.should be_exact_routes
    [ { :name=>"preview_new_admin_account", :verb=>''   , :path=>"/admin/account/new/preview(.:format)", :action=>'preview', :controller=>'account' },
      { :name=>      "login_admin_account", :verb=>'GET', :path=>"/admin/account/login(.:format)"      , :action=>'login'  , :controller=>'account' },
      { :name=>"admin_account_new_preview", :verb=>''   , :path=>"/admin/account/new/preview(.:format)", :action=>'preview', :controller=>'account' },
      { :name=>"admin_account_login"      , :verb=>'GET', :path=>"/admin/account/login(.:format)"      , :action=>'login'  , :controller=>'account' }
      ].should be_assorted_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:account,:accounts], :provide=>:classic,
      :name_prefix=>'admin_', :path_prefix=>'/admin', :member=>{:login=>:get}, :new=>{:preview=>:any} }
    should_have_collec_classics :account, :accounts, :name_prefix=>'admin_', :path_prefix=>'admin/'
    should_be_named_route '/admin/accounts/1/login'    ,'login_admin_account'      , :id=>1
    should_be_named_route '/admin/accounts/new'        ,'new_admin_account'
    should_be_named_route '/admin/accounts/new/preview','preview_new_admin_account'
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:account,:accounts], :provide=>:classic,
      :name_prefix=>'admin_', :path_prefix=>'/admin', :member=>{:login=>:get}, :new=>{:preview=>:any} }
    should_have_singleton_classics :account,         :name_prefix=>'admin_', :path_prefix=>'admin/'
    should_be_named_route '/admin/account/login'      ,'login_admin_account'
    should_be_named_route '/admin/account/new'        ,'new_admin_account'
    should_be_named_route '/admin/account/new/preview','preview_new_admin_account'
    end
  it "is not confused by collection and member actions of the same name" do
    actions = {'a'=>:get}
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all,
      :name_prefix=>"name_prefix_", :path_prefix=>'/path_prefix/:path_prefix_id', :collection=>actions, :member=>actions }
    exp_route_ar = Array.new(RT.all_route_ar)
    exp_route_ar.insert_above(RT.classic_index, { :name=>'a_plural'     , :verb=>'GET', :path=>'/plural/a(.:format)'      ,:action=>'a', :controller=>'singular' } )
    exp_route_ar.insert_above(RT.classic_show , { :name=>'a_singular'   , :verb=>'GET', :path=>'/plural/:id/a(.:format)'  ,:action=>'a', :controller=>'singular' } )
    exp_route_ar.insert_above(RT.restful_index, { :name=>'singular_a'   , :verb=>'GET', :path=>'/singular/a(.:format)'    ,:action=>'a', :controller=>'singular' } )
    exp_route_ar.insert_above(RT.restful_show , { :name=>'singular_id_a', :verb=>'GET', :path=>'/singular/:id/a(.:format)',:action=>'a', :controller=>'singular' } )
    exp_route_ar.collect {|orig_r| r = orig_r.dup
      unless r[:name].blank?
        r[:name] = ( r[:name] =~ /^(new_|edit_|a_)/ ? r[:name].sub(/(new_|edit_|a_)/, "#{$1}name_prefix_") : "name_prefix_#{r[:name]}" )
        end
      r[:path] = "/path_prefix/:path_prefix_id#{r[:path]}"
      r }.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all,
      :name_prefix=>"name_prefix_", :path_prefix=>'/path_prefix/:path_prefix_id', :collection=>actions, :member=>actions }
    exp_route_ar = Array.new(RT.s_all_route_ar)
    exp_route_ar.insert_above(RT.s_classic_show, { :name=>'a_singular'   , :verb=>'GET', :path=>'/singular/a(.:format)'    ,:action=>'a', :controller=>'singular' } )
    exp_route_ar.insert_above(RT.s_restful_show, { :name=>'singular_a'   , :verb=>'GET', :path=>'/singular/a(.:format)'    ,:action=>'a', :controller=>'singular' } )
    exp_route_ar.collect {|orig_r| r = orig_r.dup
      unless r[:name].blank?
        r[:name] = ( r[:name] =~ /^(new_|edit_|a_)/ ? r[:name].sub(/(new_|edit_|a_)/, "#{$1}name_prefix_") : "name_prefix_#{r[:name]}" )
        end
      r[:path] = "/path_prefix/:path_prefix_id#{r[:path]}"
      r }.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic,
      :name_prefix=>'thread_', :path_prefix=>'/thread/:thread_id', :collection=>actions, :member=>actions }
    should_have_collec_classics :message, :messages, :name_prefix=>'thread_', :path_prefix=>'thread/5/', :options=>{:thread_id=>'5'}
    should_be_named_route '/thread/5/messages/a'    ,'a_thread_messages', :thread_id=>'5'
    should_be_named_route '/thread/5/messages/1/a'  ,'a_thread_message' , :thread_id=>'5', :id=>'1'
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic,
      :name_prefix=>'thread_', :path_prefix=>'/thread/:thread_id', :collection=>actions, :member=>actions }
    should_have_singleton_classics :message,         :name_prefix=>'thread_', :path_prefix=>'thread/5/', :options=>{:thread_id=>'5'}
    should_be_named_route '/thread/5/message/a'     ,'a_thread_message' , :thread_id=>'5'
    end
  it 'incorporates ActionController::Base.resource_action_separator into generated routes' do
    begin
      orig_a_sep  = ActionController::Base.resource_action_separator
      ActionController::Base.resource_action_separator = @a_sep = orig_a_sep=='/' ? ';' : '/'
      big_opts = {
        :provide=>:all,
        :path_prefix=>'p',
        :name_prefix=>'nom_',
        :collection =>{:cget=>:get,              :cput=>:put,:cdel=>:delete},
        :member     =>{:mget=>:get,:mpost=>:post,            :mdel=>:delete},
        :new        =>{            :npost=>:post,:nput=>:put,:ndel=>:delete},
        }

      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], big_opts }
      exp_route_ar = RT.classic_route_ar.collect {|orig_r| orig_r.dup }
      exp_route_ar.collect! {|r| next if r.nil?
        r[:name] = r[:name].gsub(/singular/,'nom_singular').gsub(/plural/,'nom_plural')
        r[:path] = "/p#{r[:path]}"
        r[:path].gsub!(/#{orig_a_sep}edit/ ,"#{@a_sep}edit")
        r }
      exp_route_ar.should be_assorted_routes
      [ { :name=> 'ndel_new_nom_singular', :verb=>'DELETE',:path=>"/p/plural/new#{@a_sep}ndel(.:format)" ,:action=>'ndel' ,:controller=>'singular' },
        { :name=>'npost_new_nom_singular', :verb=>'POST'  ,:path=>"/p/plural/new#{@a_sep}npost(.:format)",:action=>'npost',:controller=>'singular' },
        { :name=> 'nput_new_nom_singular', :verb=>'PUT'   ,:path=>"/p/plural/new#{@a_sep}nput(.:format)" ,:action=>'nput' ,:controller=>'singular' },
        { :name=>       'cdel_nom_plural', :verb=>'DELETE',:path=>"/p/plural#{@a_sep}cdel(.:format)"     ,:action=>'cdel' ,:controller=>'singular' },
        { :name=>       'cget_nom_plural', :verb=>'GET'   ,:path=>"/p/plural#{@a_sep}cget(.:format)"     ,:action=>'cget' ,:controller=>'singular' },
        { :name=>       'cput_nom_plural', :verb=>'PUT'   ,:path=>"/p/plural#{@a_sep}cput(.:format)"     ,:action=>'cput' ,:controller=>'singular' },
        { :name=>     'mdel_nom_singular', :verb=>'DELETE',:path=>"/p/plural/:id#{@a_sep}mdel(.:format)" ,:action=>'mdel' ,:controller=>'singular' },
        { :name=>     'mget_nom_singular', :verb=>'GET'   ,:path=>"/p/plural/:id#{@a_sep}mget(.:format)" ,:action=>'mget' ,:controller=>'singular' },
        { :name=>    'mpost_nom_singular', :verb=>'POST'  ,:path=>"/p/plural/:id#{@a_sep}mpost(.:format)",:action=>'mpost',:controller=>'singular' }
        ].should be_assorted_routes
      exp_route_ar = RT.pretty_plus_restful_route_ar.collect {|orig_r| orig_r.dup }
      exp_route_ar.collect! {|r| next if r.nil?
        r[:name] = r[:name].gsub(/singular/,'nom_singular')
        r[:path] = "/p#{r[:path]}"
        r[:path].gsub!(/#{orig_a_sep}edit/     ,"#{@a_sep}edit"   )
        r[:path].gsub!(/#{orig_a_sep}show/     ,"#{@a_sep}show"   )
        r[:path].gsub!(/#{orig_a_sep}update/   ,"#{@a_sep}update" )
        r[:path].gsub!(/#{orig_a_sep}destroy/  ,"#{@a_sep}destroy")
        r }
      exp_route_ar.should be_assorted_routes
      [ { :name=>'nom_singular_new_ndel'   , :verb=>'DELETE',:path=>"/p/singular/new#{@a_sep}ndel(.:format)" ,:action=>'ndel' ,:controller=>'singular' },
        { :name=>'nom_singular_new_npost'  , :verb=>'POST'  ,:path=>"/p/singular/new#{@a_sep}npost(.:format)",:action=>'npost',:controller=>'singular' },
        { :name=>'nom_singular_new_nput'   , :verb=>'PUT'   ,:path=>"/p/singular/new#{@a_sep}nput(.:format)" ,:action=>'nput' ,:controller=>'singular' },
        { :name=>'nom_singular_cdel'       , :verb=>'DELETE',:path=>"/p/singular#{@a_sep}cdel(.:format)"     ,:action=>'cdel' ,:controller=>'singular' },
        { :name=>'nom_singular_cget'       , :verb=>'GET'   ,:path=>"/p/singular#{@a_sep}cget(.:format)"     ,:action=>'cget' ,:controller=>'singular' },
        { :name=>'nom_singular_cput'       , :verb=>'PUT'   ,:path=>"/p/singular#{@a_sep}cput(.:format)"     ,:action=>'cput' ,:controller=>'singular' },
        { :name=>'nom_singular_id_mdel'    , :verb=>'DELETE',:path=>"/p/singular/:id#{@a_sep}mdel(.:format)" ,:action=>'mdel' ,:controller=>'singular' },
        { :name=>'nom_singular_id_mget'    , :verb=>'GET'   ,:path=>"/p/singular/:id#{@a_sep}mget(.:format)" ,:action=>'mget' ,:controller=>'singular' },
        { :name=>'nom_singular_id_mpost'   , :verb=>'POST'  ,:path=>"/p/singular/:id#{@a_sep}mpost(.:format)",:action=>'mpost',:controller=>'singular' }
        ].should be_assorted_routes

      @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource [:singular,:plural], big_opts }
      exp_route_ar = RT.s_classic_route_ar.collect {|orig_r| orig_r.dup }
      exp_route_ar.collect! {|r| next if r.nil?
        r[:name] = r[:name].gsub(/singular/,'nom_singular').gsub(/plural/,'nom_plural')
        r[:path] = "/p#{r[:path]}"
        r[:path].gsub!(/#{orig_a_sep}edit/, "#{@a_sep}edit")
        r }
      exp_route_ar.should be_assorted_routes
      [ { :name=> 'ndel_new_nom_singular', :verb=>'DELETE'  ,:path=>"/p/singular/new#{@a_sep}ndel(.:format)" ,:action=>'ndel' ,:controller=>'singular' },
        { :name=>'npost_new_nom_singular', :verb=>'POST'    ,:path=>"/p/singular/new#{@a_sep}npost(.:format)",:action=>'npost',:controller=>'singular' },
        { :name=> 'nput_new_nom_singular', :verb=>'PUT'     ,:path=>"/p/singular/new#{@a_sep}nput(.:format)" ,:action=>'nput' ,:controller=>'singular' },
        { :name=>     'cdel_nom_singular', :verb=>'DELETE'  ,:path=>"/p/singular#{@a_sep}cdel(.:format)"     ,:action=>'cdel' ,:controller=>'singular' },
        { :name=>     'cget_nom_singular', :verb=>'GET'     ,:path=>"/p/singular#{@a_sep}cget(.:format)"     ,:action=>'cget' ,:controller=>'singular' },
        { :name=>     'cput_nom_singular', :verb=>'PUT'     ,:path=>"/p/singular#{@a_sep}cput(.:format)"     ,:action=>'cput' ,:controller=>'singular' },
        { :name=>     'mdel_nom_singular', :verb=>'DELETE'  ,:path=>"/p/singular#{@a_sep}mdel(.:format)"     ,:action=>'mdel' ,:controller=>'singular' },
        { :name=>     'mget_nom_singular', :verb=>'GET'     ,:path=>"/p/singular#{@a_sep}mget(.:format)"     ,:action=>'mget' ,:controller=>'singular' },
        { :name=>    'mpost_nom_singular', :verb=>'POST'    ,:path=>"/p/singular#{@a_sep}mpost(.:format)"    ,:action=>'mpost',:controller=>'singular' }
        ].should be_assorted_routes
      exp_route_ar = RT.s_pretty_plus_restful_route_ar.but_without(*RT.s_restful_c_u_d_ar).collect {|orig_r| orig_r.dup }
      exp_route_ar.collect! {|r| next if r.nil?
        r[:name] = r[:name].gsub(/singular/,'nom_singular')
        r[:path] = "/p#{r[:path]}"
        r[:path].gsub!(/#{orig_a_sep}edit/     ,"#{@a_sep}edit"   )
        r[:path].gsub!(/#{orig_a_sep}show/     ,"#{@a_sep}show"   )
        r[:path].gsub!(/#{orig_a_sep}update/   ,"#{@a_sep}update" )
        r[:path].gsub!(/#{orig_a_sep}destroy/  ,"#{@a_sep}destroy")
        r }
      exp_route_ar.should be_assorted_routes
      [ { :name=>'nom_singular_new_ndel'   , :verb=>'DELETE',:path=>"/p/singular/new#{@a_sep}ndel(.:format)"         ,:action=>'ndel' ,:controller=>'singular' },
        { :name=>'nom_singular_new_npost'  , :verb=>'POST'  ,:path=>"/p/singular/new#{@a_sep}npost(.:format)"        ,:action=>'npost',:controller=>'singular' },
        { :name=>'nom_singular_new_nput'   , :verb=>'PUT'   ,:path=>"/p/singular/new#{@a_sep}nput(.:format)"         ,:action=>'nput' ,:controller=>'singular' },
        { :name=>'nom_singular_cdel'       , :verb=>'DELETE',:path=>"/p/singular#{@a_sep}cdel(.:format)"             ,:action=>'cdel' ,:controller=>'singular' },
        { :name=>'nom_singular_cget'       , :verb=>'GET'   ,:path=>"/p/singular#{@a_sep}cget(.:format)"             ,:action=>'cget' ,:controller=>'singular' },
        { :name=>'nom_singular_cput'       , :verb=>'PUT'   ,:path=>"/p/singular#{@a_sep}cput(.:format)"             ,:action=>'cput' ,:controller=>'singular' },
        { :name=>'nom_singular_mdel'       , :verb=>'DELETE',:path=>"/p/singular#{@a_sep}mdel(.:format)"             ,:action=>'mdel' ,:controller=>'singular' },
        { :name=>'nom_singular_mget'       , :verb=>'GET'   ,:path=>"/p/singular#{@a_sep}mget(.:format)"             ,:action=>'mget' ,:controller=>'singular' },
        { :name=>'nom_singular_mpost'      , :verb=>'POST'  ,:path=>"/p/singular#{@a_sep}mpost(.:format)"            ,:action=>'mpost',:controller=>'singular' }
        ].should be_assorted_routes

    ensure
      @a_sep = ActionController::Base.resource_action_separator = orig_a_sep
    end ; end
  it 'applies :id_name_suffix option' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :id_name_suffix=>'_ID' }
    RT.classic_route_ar.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/_id$/,'_ID').gsub(/_id_/,'_ID_')
      r }.should be_consecutive_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :id_name_suffix=>'_ID' }
    RT.s_classic_route_ar.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.but_without(*RT.s_restful_c_u_d_ar).should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :id_name_suffix=>'ID' }
    RT.classic_route_ar.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/_id$/,'ID').gsub(/_id_/,'ID_')
      r }.should be_consecutive_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :id_name_suffix=>'ID' }
    RT.s_classic_route_ar.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.but_without(*RT.s_restful_c_u_d_ar).should be_consecutive_routes
    end
  it 'applies :root_name_suffix option' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :root_name_suffix=>'_ROOT' }
    RT.classic_route_ar.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/_root$/,'_ROOT').gsub(/_root_/,'_ROOT_')
      r }.should be_consecutive_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :root_name_suffix=>'_ROOT' }
    RT.s_classic_route_ar.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.but_without(*RT.s_restful_c_u_d_ar).collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/_root$/,'_ROOT').gsub(/_root_/,'_ROOT_')
      r }.should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :root_name_suffix=>'ROOT' }
    RT.classic_route_ar.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/_root$/,'ROOT').gsub(/_root_/,'ROOT_')
      r }.should be_consecutive_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :root_name_suffix=>'ROOT' }
    RT.s_classic_route_ar.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.but_without(*RT.s_restful_c_u_d_ar).collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/_root$/,'ROOT').gsub(/_root_/,'ROOT_')
      r }.should be_consecutive_routes
    end
  it 'applies :id_root_name_suffix option' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :id_root_name_suffix=>'_IDROOT' }
    RT.classic_route_ar.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/_id$/,'_id_IDROOT')
      r }.should be_consecutive_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :id_root_name_suffix=>'_IDROOT' }
    RT.s_classic_route_ar.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.but_without(*RT.s_restful_c_u_d_ar).should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :id_root_name_suffix=>'IDROOT' }
    RT.classic_route_ar.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/_id$/,'_idIDROOT')
      r }.should be_consecutive_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :id_root_name_suffix=>'IDROOT' }
    RT.s_classic_route_ar.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.but_without(*RT.s_restful_c_u_d_ar).should be_consecutive_routes
    end
  it 'applies :nest_id_name_suffix option to :has_many , :has_one , and nested code block' do
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.outlaw_resources [:singular,:plural], :provide=>:all, :has_one=>:singu101, :has_many=>:singu102, :nest_id_name_suffix=>'_ID' do |inner|
        inner.outlaw_resources :singu202
      end ; end
    RT.all_route_ar.should be_consecutive_routes
    RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu101')
      r[:path] = r[:path].gsub(/singular/,'plural/:singular_id/singu101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_ID_singu101')
      r[:path] = r[:path].gsub(/singular/,'singular/:singular_id/singu101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu102').gsub(/plural/,'singular_plur102')
      r[:path] = r[:path].gsub(/plural/,'plural/:singular_id/plur102')
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_ID_singu102')
      r[:path] = r[:path].gsub(/singular/,'singular/:singular_id/singu102')
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes # Contains _ID_something_id_ names, which are correct.
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu202').gsub(/plural/,'singular_plur202')
      r[:path] = r[:path].gsub(/plural/,'plural/:singular_id/plur202')
      r[:controller] = 'singu202'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_ID_singu202')
      r[:path] = r[:path].gsub(/singular/,'singular/:singular_id/singu202')
      r[:controller] = 'singu202'
      r }.should be_consecutive_routes  # Contains _ID_something_id_ names, which are correct.
    end
  it 'applies :has_many=>(Symbol or String) option, to add a nested collection' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :has_many=>'singu101' }
    exp_route_ar = Array.new(RT.all_route_ar)
    exp_route_ar += RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu101').gsub(/plural/,'singular_plur101')
      r[:path] = r[:path].gsub(/plural/,'plural/:singular_id/plur101')
      r[:controller] = 'singu101'
      r }
    exp_route_ar += RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_id_singu101')
      r[:path] = r[:path].gsub(/singular/,'singular/:singular_id/singu101')
      r[:controller] = 'singu101'
      r }
    exp_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :has_many=>'singu101' }
    exp_route_ar = Array.new(RT.s_all_route_ar)
    exp_route_ar += RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu101').gsub(/plural/,'singular_plur101')
      r[:path] = r[:path].gsub(/plural/,'singular/plur101')
      r[:controller] = 'singu101'
      r }
    exp_route_ar += RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu101')
      r[:path] = r[:path].gsub(/singular/,'singular/singu101')
      r[:controller] = 'singu101'
      r }
    exp_route_ar.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic, :has_many=>:singu101 }
    should_have_collec_classics    :message , :messages
    should_have_collec_classics    :singu101, :plur101, :controller=>'singu101' ,:name_prefix=>'message_' ,:path_prefix=>'messages/1/', :options=>{:message_id=>'1'}
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic, :has_many=>:singu101 }
    should_have_singleton_classics :message
    should_have_collec_classics    :singu101, :plur101, :controller=>'singu101' ,:name_prefix=>'message_' ,:path_prefix=>'message/'
    end
  it 'applies :has_many=>[ array of resources ] option, to add multiple nested collections' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :has_many=>[:singu101,[:singu102,:plur103]] }
    exp_route_ar = Array.new(RT.all_route_ar)
    exp_route_ar += RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu101').gsub(/plural/,'singular_plur101')
      r[:path] = r[:path].gsub(/plural/,'plural/:singular_id/plur101')
      r[:controller] = 'singu101'
      r }
    exp_route_ar += RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_id_singu101')
      r[:path] = r[:path].gsub(/singular/,'singular/:singular_id/singu101')
      r[:controller] = 'singu101'
      r }
    exp_route_ar += RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu102').gsub(/plural/,'singular_plur103')
      r[:path] = r[:path].gsub(/plural/,'plural/:singular_id/plur103')
      r[:controller] = 'singu102'
      r }
    exp_route_ar += RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_id_singu102')
      r[:path] = r[:path].gsub(/singular/,'singular/:singular_id/singu102')
      r[:controller] = 'singu102'
      r }
    exp_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :has_many=>[:singu101,[:singu102,:plur103]] }
    exp_route_ar = Array.new(RT.s_all_route_ar)
    exp_route_ar += RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu101').gsub(/plural/,'singular_plur101')
      r[:path] = r[:path].gsub(/plural/,'singular/plur101')
      r[:controller] = 'singu101'
      r }
    exp_route_ar += RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu101')
      r[:path] = r[:path].gsub(/singular/,'singular/singu101')
      r[:controller] = 'singu101'
      r }
    exp_route_ar += RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu102').gsub(/plural/,'singular_plur103')
      r[:path] = r[:path].gsub(/plural/,'singular/plur103')
      r[:controller] = 'singu102'
      r }
    exp_route_ar += RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu102')
      r[:path] = r[:path].gsub(/singular/,'singular/singu102')
      r[:controller] = 'singu102'
      r }
    exp_route_ar.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic, :has_many=>['singu101',['singu102',:plur103]] }
    should_have_collec_classics    :message , :messages
    should_have_collec_classics    :singu101, :plur101, :controller=>'singu101' ,:name_prefix=>'message_' ,:path_prefix=>'messages/1/', :options=>{:message_id=>'1'}
    should_have_collec_classics    :singu102, :plur103, :controller=>'singu102' ,:name_prefix=>'message_' ,:path_prefix=>'messages/1/', :options=>{:message_id=>'1'}
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic, :has_many=>['singu101',[:singu102,'plur103']] }
    should_have_singleton_classics :message
    should_have_collec_classics    :singu101, :plur101, :controller=>'singu101' ,:name_prefix=>'message_' ,:path_prefix=>'message/'
    should_have_collec_classics    :singu102, :plur103, :controller=>'singu102' ,:name_prefix=>'message_' ,:path_prefix=>'message/'
    end
  it 'applies :has_many=>{ hash of nested resources } option, to add a topology of nested collections' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :singu101, :provide=>:all,
      :has_many => { :singu102 => [ :singu103, {[:singu104,:plur104]=>[[:singu105,:plur105]]} ] }
      # Note that ...[:singu104,:plur104]=>[:singu105,:plur105](not array of array)... would be interpreted as a list.
      }
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101').gsub(/plural/,'plur101')
      r[:path] = r[:path].gsub(/plural/,'plur101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101')
      r[:path] = r[:path].gsub(/singular/,'singu101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu102').gsub(/plural/,'singu101_plur102')
      r[:path] = r[:path].gsub(/plural/,'plur101/:singu101_id/plur102')
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_id_singu102')
      r[:path] = r[:path].gsub(/singular/,'singu101/:singu101_id/singu102')
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu102_singu103').gsub(/plural/,'singu101_singu102_plur103')
      r[:path] = r[:path].gsub(/plural/,'plur101/:singu101_id/plur102/:singu102_id/plur103')
      r[:controller] = 'singu103'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_id_singu102_id_singu103')
      r[:path] = r[:path].gsub(/singular/,'singu101/:singu101_id/singu102/:singu102_id/singu103')
      r[:controller] = 'singu103'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu102_singu104').gsub(/plural/,'singu101_singu102_plur104')
      r[:path] = r[:path].gsub(/plural/,'plur101/:singu101_id/plur102/:singu102_id/plur104')
      r[:controller] = 'singu104'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_id_singu102_id_singu104')
      r[:path] = r[:path].gsub(/singular/,'singu101/:singu101_id/singu102/:singu102_id/singu104')
      r[:controller] = 'singu104'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu102_singu104_singu105').gsub(/plural/,'singu101_singu102_singu104_plur105')
      r[:path] = r[:path].gsub(/plural/,'plur101/:singu101_id/plur102/:singu102_id/plur104/:singu104_id/plur105')
      r[:controller] = 'singu105'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_id_singu102_id_singu104_id_singu105')
      r[:path] = r[:path].gsub(/singular/,'singu101/:singu101_id/singu102/:singu102_id/singu104/:singu104_id/singu105')
      r[:controller] = 'singu105'
      r }.should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :singu101, :provide=>:all,
      :has_many => { :singu102 => [ :singu103, {[:singu104,:plur104]=>[[:singu105,:plur105]]} ] }
      # Note that ...[:singu104,:plur104]=>[:singu105,:plur105](not array of array)... would be interpreted as a list.
      }
    RT.s_all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101')
      r[:path] = r[:path].gsub(/singular/,'singu101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu102').gsub(/plural/,'singu101_plur102')
      r[:path] = r[:path].gsub(/plural/,'singu101/plur102')
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu102')
      r[:path] = r[:path].gsub(/singular/,'singu101/singu102')
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu102_singu103').gsub(/plural/,'singu101_singu102_plur103')
      r[:path] = r[:path].gsub(/plural/,'singu101/plur102/:singu102_id/plur103')
      r[:controller] = 'singu103'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu102_id_singu103')
      r[:path] = r[:path].gsub(/singular/,'singu101/singu102/:singu102_id/singu103')
      r[:controller] = 'singu103'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu102_singu104').gsub(/plural/,'singu101_singu102_plur104')
      r[:path] = r[:path].gsub(/plural/,'singu101/plur102/:singu102_id/plur104')
      r[:controller] = 'singu104'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu102_id_singu104')
      r[:path] = r[:path].gsub(/singular/,'singu101/singu102/:singu102_id/singu104')
      r[:controller] = 'singu104'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu102_singu104_singu105').gsub(/plural/,'singu101_singu102_singu104_plur105')
      r[:path] = r[:path].gsub(/plural/,'singu101/plur102/:singu102_id/plur104/:singu104_id/plur105')
      r[:controller] = 'singu105'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu102_id_singu104_id_singu105')
      r[:path] = r[:path].gsub(/singular/,'singu101/singu102/:singu102_id/singu104/:singu104_id/singu105')
      r[:controller] = 'singu105'
      r }.should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :singu101, :provide=>:classic, :has_many=>{:singu102=>[:singu103,{:singu104=>:singu105}]} }
    should_have_collec_classics    :singu101, :plur101, :controller=>'singu101'
    should_have_collec_classics :singu102, :plur102, :controller=>'singu102', :name_prefix=>'singu101_'                  , :path_prefix=>'plur101/1/'                    ,:options=>{:singu101_id=>'1'}
    should_have_collec_classics :singu103, :plur103, :controller=>'singu103', :name_prefix=>'singu101_singu102_'         , :path_prefix=>'plur101/1/plur102/1/'          ,:options=>{:singu101_id=>'1',:singu102_id=>'1'}
    should_have_collec_classics :singu104, :plur104, :controller=>'singu104', :name_prefix=>'singu101_singu102_'         , :path_prefix=>'plur101/1/plur102/1/'          ,:options=>{:singu101_id=>'1',:singu102_id=>'1'}
    should_have_collec_classics :singu105, :plur105, :controller=>'singu105', :name_prefix=>'singu101_singu102_singu104_', :path_prefix=>'plur101/1/plur102/1/plur104/1/',:options=>{:singu101_id=>'1',:singu102_id=>'1',:singu104_id=>'1'}
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :singu101, :provide=>:classic, :has_many=>{:singu102=>[:singu103,{:singu104=>:singu105}]} }
    should_have_singleton_classics :singu101,           :controller=>'singu101'
    should_have_collec_classics :singu102, :plur102, :controller=>'singu102', :name_prefix=>'singu101_'                  , :path_prefix=>'singu101/'
    should_have_collec_classics :singu103, :plur103, :controller=>'singu103', :name_prefix=>'singu101_singu102_'         , :path_prefix=>'singu101/plur102/1/'           ,:options=>{:singu102_id=>'1'}
    should_have_collec_classics :singu104, :plur104, :controller=>'singu104', :name_prefix=>'singu101_singu102_'         , :path_prefix=>'singu101/plur102/1/'           ,:options=>{:singu102_id=>'1'}
    should_have_collec_classics :singu105, :plur105, :controller=>'singu105', :name_prefix=>'singu101_singu102_singu104_', :path_prefix=>'singu101/plur102/1/plur104/1/' ,:options=>{:singu102_id=>'1',:singu104_id=>'1'}
    end
  it 'applies :has_many=>[ array of resources ] and :shallow=>true options, to add shallow-nested collections' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :singu101, :provide=>:all, :has_many=>[:singu102,:singu103], :shallow=>true }
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101').gsub(/plural/,'plur101')
      r[:path] = r[:path].gsub(/plural/,'plur101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101')
      r[:path] = r[:path].gsub(/singular/,'singu101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      if r[:path] =~ /:id/
        r[:name] = r[:name].gsub(/singular/,'singu102')
        r[:path] = r[:path].gsub(/plural/,'plur102')
      else
        r[:name] = r[:name].gsub(/singular/,'singu101_singu102').gsub(/plural/,'singu101_plur102')
        r[:path] = r[:path].gsub(/plural/,'plur101/:singu101_id/plur102') ; end
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      if r[:path] =~ /:id/
        r[:name] = r[:name].gsub(/singular/,'singu102')
        r[:path] = r[:path].gsub(/singular/,'singu102')
      else
        r[:name] = r[:name].gsub(/singular/,'singu101_id_singu102')
        r[:path] = r[:path].gsub(/singular/,'singu101/:singu101_id/singu102') ; end
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      if r[:path] =~ /:id/
        r[:name] = r[:name].gsub(/singular/,'singu103')
        r[:path] = r[:path].gsub(/plural/,'plur103')
      else
        r[:name] = r[:name].gsub(/singular/,'singu101_singu103').gsub(/plural/,'singu101_plur103')
        r[:path] = r[:path].gsub(/plural/,'plur101/:singu101_id/plur103') ; end
      r[:controller] = 'singu103'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      if r[:path] =~ /:id/
        r[:name] = r[:name].gsub(/singular/,'singu103')
        r[:path] = r[:path].gsub(/singular/,'singu103')
      else
        r[:name] = r[:name].gsub(/singular/,'singu101_id_singu103')
        r[:path] = r[:path].gsub(/singular/,'singu101/:singu101_id/singu103') ; end
      r[:controller] = 'singu103'
      r }.should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :singu101, :provide=>:all, :has_many=>[:singu102,:singu103], :shallow=>true }
    RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101')
      r[:path] = r[:path].gsub(/singular/,'singu101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.but_without(*RT.s_restful_c_u_d_ar).collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101')
      r[:path] = r[:path].gsub(/singular/,'singu101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      if r[:path] =~ /:id/
        r[:name] = r[:name].gsub(/singular/,'singu102')
        r[:path] = r[:path].gsub(/plural/,'plur102')
      else
        r[:name] = r[:name].gsub(/singular/,'singu101_singu102').gsub(/plural/,'singu101_plur102')
        r[:path] = r[:path].gsub(/plural/,'singu101/plur102') ; end
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      if r[:path] =~ /:id/
        r[:name] = r[:name].gsub(/singular/,'singu102')
        r[:path] = r[:path].gsub(/singular/,'singu102')
      else
        r[:name] = r[:name].gsub(/singular/,'singu101_singu102')
        r[:path] = r[:path].gsub(/singular/,'singu101/singu102') ; end
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      if r[:path] =~ /:id/
        r[:name] = r[:name].gsub(/singular/,'singu103')
        r[:path] = r[:path].gsub(/plural/,'plur103')
      else
        r[:name] = r[:name].gsub(/singular/,'singu101_singu103').gsub(/plural/,'singu101_plur103')
        r[:path] = r[:path].gsub(/plural/,'singu101/plur103') ; end
      r[:controller] = 'singu103'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      if r[:path] =~ /:id/
        r[:name] = r[:name].gsub(/singular/,'singu103')
        r[:path] = r[:path].gsub(/singular/,'singu103')
      else
        r[:name] = r[:name].gsub(/singular/,'singu101_singu103')
        r[:path] = r[:path].gsub(/singular/,'singu101/singu103') ; end
      r[:controller] = 'singu103'
      r }.should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :singu101, :provide=>:classic, :controller=>:plur1, :has_many=>[:singu102,:singu103], :shallow=>true }
    should_have_collec_classics    :singu101, :plur101, :controller=>'plur1'
    should_have_collec_classics :singu102, :plur102, :controller=>'singu102', :name_prefix=>'singu101_', :path_prefix=>'plur101/1/', :shallow=>true, :options=>{:singu101_id=>'1'}
    should_have_collec_classics :singu103, :plur103, :controller=>'singu103', :name_prefix=>'singu101_', :path_prefix=>'plur101/1/', :shallow=>true, :options=>{:singu101_id=>'1'}
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :singu101, :provide=>:classic, :controller=>:plur1, :has_many=>[:singu102,:singu103], :shallow=>true }
    should_have_singleton_classics :singu101,           :controller=>'plur1'
    should_have_collec_classics :singu102, :plur102, :controller=>'singu102', :name_prefix=>'singu101_', :path_prefix=>'singu101/', :shallow=>true
    should_have_collec_classics :singu103, :plur103, :controller=>'singu103', :name_prefix=>'singu101_', :path_prefix=>'singu101/', :shallow=>true
    end
  it 'applies :has_one=>(Symbol or String) option, to add a nested singleton' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :has_one=>:singu102 }
    RT.all_route_ar.should be_consecutive_routes
    RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu102')
      r[:path] = r[:path].gsub(/singular/,'plural/:singular_id/singu102')
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_id_singu102')
      r[:path] = r[:path].gsub(/singular/,'singular/:singular_id/singu102')
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :has_one=>'singu102' }
    RT.s_all_route_ar.should be_consecutive_routes
    RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu102')
      r[:path] = r[:path].gsub(/singular/,'singular/singu102')
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.but_without(*RT.s_restful_c_u_d_ar).collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu102')
      r[:path] = r[:path].gsub(/singular/,'singular/singu102')
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :singu101, :provide=>:classic, :has_one=>:singu102 }
    should_have_collec_classics    :singu101, :plur101, :controller=>'singu101'
    should_have_singleton_classics :singu102          , :controller=>'singu102', :name_prefix=>'singu101_', :path_prefix=>'plur101/1/', :options=>{:singu101_id=>'1'}
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :singu101, :provide=>:classic, :has_one=>:singu102 }
    should_have_singleton_classics :singu101,           :controller=>'singu101'
    should_have_singleton_classics :singu102          , :controller=>'singu102', :name_prefix=>'singu101_', :path_prefix=>'singu101/'
    end
  it 'applies :has_one and :shallow options, to add a nested singleton (:shallow has no effect on singletons)' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :has_one=>:singu102, :shallow=>true }
    RT.all_route_ar.should be_consecutive_routes
    RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu102')
      r[:path] = r[:path].gsub(/singular/,'plural/:singular_id/singu102')
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_id_singu102')
      r[:path] = r[:path].gsub(/singular/,'singular/:singular_id/singu102')
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :has_one=>:singu102, :shallow=>true }
    RT.s_all_route_ar.should be_consecutive_routes
    RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu102')
      r[:path] = r[:path].gsub(/singular/,'singular/singu102')
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.but_without(*RT.s_restful_c_u_d_ar).collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu102')
      r[:path] = r[:path].gsub(/singular/,'singular/singu102')
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources :singu101, :provide=>:classic, :has_one=>:singu102, :shallow=>true }
    should_have_collec_classics    :singu101, :plur101, :controller=>'singu101'
    should_have_singleton_classics :singu102,           :controller=>'singu102', :name_prefix=>'singu101_', :path_prefix=>'plur101/1/', :options=>{:singu101_id=>'1'}
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  :singu101, :provide=>:classic, :has_one=>:singu102, :shallow=>true }
    should_have_singleton_classics :singu101,           :controller=>'singu101'
    should_have_singleton_classics :singu102,           :controller=>'singu102', :name_prefix=>'singu101_', :path_prefix=>'singu101/'
    end
  it 'executes nested code block containing calls to outlaw_resources()' do
    @scratch_routes.clear! ; @scratch_routes.draw       do |map|
      map.outlaw_resources    :singu101, :provide=>:all do |c1|
        c1.outlaw_resources   :singu201, :provide=>:all do |c2|
          c2.outlaw_resources :singu301, :provide=>:all
      end ; end ; end
    RT.all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101').gsub(/plural/,'plur101')
      r[:path] = r[:path].gsub(/plural/,'plur101').gsub(/singular/,'singu101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu201').gsub(/plural/,'singu101_plur201')
      r[:path] = r[:path].gsub(/plural/,'plur101/:singu101_id/plur201')
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_id_singu201')
      r[:path] = r[:path].gsub(/singular/,'singu101/:singu101_id/singu201')
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu201_singu301').gsub(/plural/,'singu101_singu201_plur301')
      r[:path] = r[:path].gsub(/plural/,'plur101/:singu101_id/plur201/:singu201_id/plur301')
      r[:controller] = 'singu301'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_id_singu201_id_singu301')
      r[:path] = r[:path].gsub(/singular/,'singu101/:singu101_id/singu201/:singu201_id/singu301')
      r[:controller] = 'singu301'
      r }.should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw       do |map|
      map.outlaw_resource     :singu101, :provide=>:all do |s1|
        s1.outlaw_resources   :singu201, :provide=>:all do |c2|
          c2.outlaw_resources :singu301, :provide=>:all
      end ; end ; end
    RT.s_all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101')
      r[:path] = r[:path].gsub(/singular/,'singu101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu201').gsub(/plural/,'singu101_plur201')
      r[:path] = r[:path].gsub(/plural/,'singu101/plur201')
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu201')
      r[:path] = r[:path].gsub(/singular/,'singu101/singu201')
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu201_singu301').gsub(/plural/,'singu101_singu201_plur301')
      r[:path] = r[:path].gsub(/plural/,'singu101/plur201/:singu201_id/plur301')
      r[:controller] = 'singu301'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu201_id_singu301')
      r[:path] = r[:path].gsub(/singular/,'singu101/singu201/:singu201_id/singu301')
      r[:controller] = 'singu301'
      r }.should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw                      do |map|
      map.outlaw_resources    [:thread ,:threads ], :provide=>:classic do |c1|
        c1.outlaw_resources   [:message,:messages], :provide=>:classic do |c2|
          c2.outlaw_resources [:comment,:comments], :provide=>:classic
      end ; end ; end
    should_have_collec_classics    :thread , :threads
    should_have_collec_classics :message, :messages, :name_prefix=>'thread_'        , :path_prefix=>'threads/1/'           , :options=>{:thread_id=>'1'}
    should_have_collec_classics :comment, :comments, :name_prefix=>'thread_message_', :path_prefix=>'threads/1/messages/2/', :options=>{:thread_id=>'1',:message_id=>'2'}
    @scratch_routes.clear! ; @scratch_routes.draw                      do |map|
      map.outlaw_resource     [:thread ,:threads ], :provide=>:classic do |s1|
        s1.outlaw_resources   [:message,:messages], :provide=>:classic do |c2|
          c2.outlaw_resources [:comment,:comments], :provide=>:classic
      end ; end ; end
    should_have_singleton_classics :thread
    should_have_collec_classics :message, :messages, :name_prefix=>'thread_'        , :path_prefix=>'thread/'
    should_have_collec_classics :comment, :comments, :name_prefix=>'thread_message_', :path_prefix=>'thread/messages/2/'   , :options=>{:message_id=>'2'}
    end
  it 'executes nested code block containing calls to outlaw_resource()' do
    @scratch_routes.clear! ; @scratch_routes.draw       do |map|
      map.outlaw_resources    :singu101, :provide=>:all do |c1|
        c1.outlaw_resource    :singu201, :provide=>:all do |s2|
          s2.outlaw_resource  :singu301, :provide=>:all
      end ; end ; end
    RT.all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101').gsub(/plural/,'plur101')
      r[:path] = r[:path].gsub(/plural/,'plur101').gsub(/singular/,'singu101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu201')
      r[:path] = r[:path].gsub(/singular/,'plur101/:singu101_id/singu201')
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_id_singu201')
      r[:path] = r[:path].gsub(/singular/,'singu101/:singu101_id/singu201')
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu201_singu301')
      r[:path] = r[:path].gsub(/singular/,'plur101/:singu101_id/singu201/singu301')
      r[:controller] = 'singu301'
      r }.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_id_singu201_singu301')
      r[:path] = r[:path].gsub(/singular/,'singu101/:singu101_id/singu201/singu301')
      r[:controller] = 'singu301'
      r }.should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw       do |map|
      map.outlaw_resource     :singu101, :provide=>:all do |s1|
        s1.outlaw_resource    :singu201, :provide=>:all do |s2|
          s2.outlaw_resource  :singu301, :provide=>:all
      end ; end ; end
    RT.s_all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101')
      r[:path] = r[:path].gsub(/singular/,'singu101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu201')
      r[:path] = r[:path].gsub(/singular/,'singu101/singu201')
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.but_without(*RT.s_restful_c_u_d_ar).collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu201')
      r[:path] = r[:path].gsub(/singular/,'singu101/singu201')
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu201_singu301')
      r[:path] = r[:path].gsub(/singular/,'singu101/singu201/singu301')
      r[:controller] = 'singu301'
      r }.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.but_without(*RT.s_restful_c_u_d_ar).collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu201_singu301')
      r[:path] = r[:path].gsub(/singular/,'singu101/singu201/singu301')
      r[:controller] = 'singu301'
      r }.should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw                      do |map|
      map.outlaw_resources    [:thread ,:threads ], :provide=>:classic do |c1|
        c1.outlaw_resource    [:message,:messages], :provide=>:classic do |s2|
          s2.outlaw_resource  [:comment,:comments], :provide=>:classic
      end ; end ; end
    should_have_collec_classics    :thread , :threads
    should_have_singleton_classics :message,          :name_prefix=>'thread_'        , :path_prefix=>'threads/1/'        , :options=>{:thread_id=>'1'}
    should_have_singleton_classics :comment,          :name_prefix=>'thread_message_', :path_prefix=>'threads/1/message/', :options=>{:thread_id=>'1'}
    @scratch_routes.clear! ; @scratch_routes.draw                      do |map|
      map.outlaw_resource     [:thread ,:threads ], :provide=>:classic do |s1|
        s1.outlaw_resource    [:message,:messages], :provide=>:classic do |s2|
          s2.outlaw_resource  [:comment,:comments], :provide=>:classic
      end ; end ; end
    should_have_singleton_classics :thread
    should_have_singleton_classics :message,          :name_prefix=>'thread_'        , :path_prefix=>'thread/'
    should_have_singleton_classics :comment,          :name_prefix=>'thread_message_', :path_prefix=>'thread/message/'
    end
  it 'executes nested code block containing outlaw_resources(...:name_prefix=>nil)' do
    @scratch_routes.clear! ; @scratch_routes.draw                          do |map|
      map.outlaw_resources    :singu101, :provide=>:all                    do |c1|
        c1.outlaw_resources   :singu201, :provide=>:all, :name_prefix=>nil do |c2|
          c2.outlaw_resources :singu301, :provide=>:all, :name_prefix=>nil
      end ; end ; end
    RT.all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101').gsub(/plural/,'plur101')
      r[:path] = r[:path].gsub(/singular/,'singu101').gsub(/plural/,'plur101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu201').gsub(/plural/,'plur201')
      r[:path] = r[:path].gsub(/plural/,'plur101/:singu101_id/plur201')
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu201')
      r[:path] = r[:path].gsub(/singular/,'singu101/:singu101_id/singu201')
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu301').gsub(/plural/,'plur301')
      r[:path] = r[:path].gsub(/plural/,'plur101/:singu101_id/plur201/:singu201_id/plur301')
      r[:controller] = 'singu301'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu301').gsub(/plural/,'plur301')
      r[:path] = r[:path].gsub(/singular/,'singu101/:singu101_id/singu201/:singu201_id/singu301')
      r[:controller] = 'singu301'
      r }.should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw                          do |map|
      map.outlaw_resource     :singu101, :provide=>:all                    do |s1|
        s1.outlaw_resources   :singu201, :provide=>:all, :name_prefix=>nil do |c2|
          c2.outlaw_resources :singu301, :provide=>:all, :name_prefix=>nil
      end ; end ; end
    RT.s_all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101')
      r[:path] = r[:path].gsub(/singular/,'singu101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu201').gsub(/plural/,'plur201')
      r[:path] = r[:path].gsub(/plural/,'singu101/plur201')
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu201')
      r[:path] = r[:path].gsub(/singular/,'singu101/singu201')
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu301').gsub(/plural/,'plur301')
      r[:path] = r[:path].gsub(/plural/,'singu101/plur201/:singu201_id/plur301')
      r[:controller] = 'singu301'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu301').gsub(/plural/,'plur301')
      r[:path] = r[:path].gsub(/singular/,'singu101/singu201/:singu201_id/singu301')
      r[:controller] = 'singu301'
      r }.should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw                                         do |map|
      map.outlaw_resources    [:thread ,:threads ], :provide=>:classic                    do |c1|
        c1.outlaw_resources   [:message,:messages], :provide=>:classic, :name_prefix=>nil do |c2|
          c2.outlaw_resources [:comment,:comments], :provide=>:classic, :name_prefix=>nil
      end ; end ; end
    should_have_collec_classics    :thread , :threads
    should_have_collec_classics :message, :messages , :path_prefix=>'threads/1/'           , :options=>{:thread_id=>'1'}
    should_have_collec_classics :comment, :comments , :path_prefix=>'threads/1/messages/2/', :options=>{:thread_id=>'1',:message_id=>'2'}
    @scratch_routes.clear! ; @scratch_routes.draw                                         do |map|
      map.outlaw_resource     [:thread ,:threads ], :provide=>:classic                    do |s1|
        s1.outlaw_resources   [:message,:messages], :provide=>:classic, :name_prefix=>nil do |c2|
          c2.outlaw_resources [:comment,:comments], :provide=>:classic, :name_prefix=>nil
      end ; end ; end
    should_have_singleton_classics :thread
    should_have_collec_classics :message, :messages , :path_prefix=>'thread/'
    should_have_collec_classics :comment, :comments , :path_prefix=>'thread/messages/2/'   , :options=>{:message_id=>'2'}
    end
  it 'applies :path_prefix option, and then executes nested outlaw_resources() call without :path_prefix' do
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.outlaw_resources       [:account,:accounts], :provide=>:all, :path_prefix=>':site_id' do |account|
        account.outlaw_resources [:message,:messages], :provide=>:all
      end ; end
    RT.all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'account').gsub(/plural/,'accounts')
      r[:path] = r[:path].gsub(/singular/,':site_id/account').gsub(/plural/,':site_id/accounts')
      r[:controller] = 'account'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'account_message').gsub(/plural/,'account_messages')
      r[:path] = r[:path].gsub(/plural/,':site_id/accounts/:account_id/messages')
      r[:controller] = 'message'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'account_id_message')
      r[:path] = r[:path].gsub(/singular/,':site_id/account/:account_id/message')
      r[:controller] = 'message'
      r }.should be_consecutive_routes
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.outlaw_resource        [:account,:accounts], :provide=>:all, :path_prefix=>':site_id' do |account|
        account.outlaw_resources [:message,:messages], :provide=>:all
      end ; end
    RT.s_all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'account')
      r[:path] = r[:path].gsub(/singular/,':site_id/account')
      r[:controller] = 'account'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'account_message').gsub(/plural/,'account_messages')
      r[:path] = r[:path].gsub(/plural/,':site_id/account/messages')
      r[:controller] = 'message'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'account_message')
      r[:path] = r[:path].gsub(/singular/,':site_id/account/message')
      r[:controller] = 'message'
      r }.should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.outlaw_resources       [:account,:accounts], :provide=>:classic, :path_prefix=>':site_id' do |account|
        account.outlaw_resources [:message,:messages], :provide=>:classic
      end ; end
    should_have_collec_refer_classics    :account, :accounts, :controller=>'account',                           :path_prefix=>'7/'           , :options=>{:site_id=>'7'}
    should_have_collec_classics          :message, :messages, :controller=>'message', :name_prefix=>'account_', :path_prefix=>'7/accounts/5/', :options=>{:site_id=>'7',:account_id=>'5'}
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.outlaw_resource        [:account,:accounts], :provide=>:classic, :path_prefix=>':site_id' do |account|
        account.outlaw_resources [:message,:messages], :provide=>:classic
      end ; end
    should_have_singleton_refer_classics :account,            :controller=>'account',                           :path_prefix=>'7/'        , :options=>{:site_id=>'7'}
    should_have_collec_classics          :message, :messages, :controller=>'message', :name_prefix=>'account_', :path_prefix=>'7/account/', :options=>{:site_id=>'7'}
    end

  it 'applies :shallow option, and propagates it into nested code block' do
    @scratch_routes.clear! ; @scratch_routes.draw                     do |map|
      map.outlaw_resources    :singu101,:provide=>:all,:shallow=>true do |c1|
        c1.outlaw_resources   :singu201,:provide=>:all                do |c2|
          c2.outlaw_resources :singu301,:provide=>:all
      end ; end ; end
    RT.all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101').gsub(/plural/,'plur101')
      r[:path] = r[:path].gsub(/singular/,'singu101').gsub(/plural/,'plur101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      if r[:path] =~ /:id/
        r[:name] = r[:name].gsub(/singular/,'singu201')
        r[:path] = r[:path].gsub(/plural/,'plur201')
      else
        r[:name] = r[:name].gsub(/singular/,'singu101_singu201').gsub(/plural/,'singu101_plur201')
        r[:path] = r[:path].gsub(/plural/,'plur101/:singu101_id/plur201') ; end
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      if r[:path] =~ /:id/
        r[:name] = r[:name].gsub(/singular/,'singu201')
        r[:path] = r[:path].gsub(/singular/,'singu201')
      else
        r[:name] = r[:name].gsub(/singular/,'singu101_id_singu201')
        r[:path] = r[:path].gsub(/singular/,'singu101/:singu101_id/singu201') ; end
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      if r[:path] =~ /:id/
        r[:name] = r[:name].gsub(/singular/,'singu301')
        r[:path] = r[:path].gsub(/plural/,'plur301')
      else
        r[:name] = r[:name].gsub(/singular/,'singu201_singu301').gsub(/plural/,'singu201_plur301')
        r[:path] = r[:path].gsub(/plural/,'plur201/:singu201_id/plur301') ; end
      r[:controller] = 'singu301'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      if r[:path] =~ /:id/
        r[:name] = r[:name].gsub(/singular/,'singu301')
        r[:path] = r[:path].gsub(/singular/,'singu301')
      else
        r[:name] = r[:name].gsub(/singular/,'singu201_id_singu301')
        r[:path] = r[:path].gsub(/singular/,'singu201/:singu201_id/singu301') ; end
      r[:controller] = 'singu301'
      r }.should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw                          do |map|
      map.outlaw_resource     :singu101, :provide=>:all, :shallow=>true    do |s1|
        s1.outlaw_resource    :singu201, :provide=>:all                    do |s2|
          s2.outlaw_resources :singu301, :provide=>:all
      end ; end ; end
    RT.s_all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101')
      r[:path] = r[:path].gsub(/singular/,'singu101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu201')
      r[:path] = r[:path].gsub(/singular/,'singu101/singu201')
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.but_without(*RT.s_restful_c_u_d_ar).collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singu101_singu201')
      r[:path] = r[:path].gsub(/singular/,'singu101/singu201')
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      if r[:path] =~ /:id/
        r[:name] = r[:name].gsub(/singular/,'singu301')
        r[:path] = r[:path].gsub(/plural/,'plur301')
      else
        r[:name] = r[:name].gsub(/singular/,'singu101_singu201_singu301').gsub(/plural/,'singu101_singu201_plur301')
        r[:path] = r[:path].gsub(/plural/,'singu101/singu201/plur301') ; end
      r[:controller] = 'singu301'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      if r[:path] =~ /:id/
        r[:name] = r[:name].gsub(/singular/,'singu301')
        r[:path] = r[:path].gsub(/singular/,'singu301')
      else
        r[:name] = r[:name].gsub(/singular/,'singu101_singu201_singu301')
        r[:path] = r[:path].gsub(/singular/,'singu101/singu201/singu301') ; end
      r[:controller] = 'singu301'
      r }.should be_consecutive_routes

    @scratch_routes.clear! ; @scratch_routes.draw                                      do |map|
      map.outlaw_resources    [:thread ,:threads ], :provide=>:classic, :shallow=>true do |c1|
        c1.outlaw_resources   [:message,:messages], :provide=>:classic                 do |c2|
          c2.outlaw_resources [:comment,:comments], :provide=>:classic
      end ; end ; end
    should_have_collec_classics :thread , :threads
    should_have_collec_classics :message, :messages, :name_prefix=>'thread_' , :path_prefix=>'threads/1/' , :options=>{:thread_id=>'1'} , :shallow=>true
    should_have_collec_classics :comment, :comments, :name_prefix=>'message_', :path_prefix=>'messages/2/', :options=>{:message_id=>'2'}, :shallow=>true
    end
  it "neither the :only nor :except option is inherited" do
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.outlaw_resources [:singular,:plural], :only=>:show, :except=>:new do |inner|
        inner.outlaw_resource  :singu201
        inner.outlaw_resources :singu202
      end ; end
    exp_route_ar = [RT.restful_show]
    exp_route_ar += RT.s_default_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_id_singu201')
      r[:path] = '/singular/:singular_id' + r[:path].gsub(/\/singular/,'/singu201')
      r[:controller] = 'singu201'
      r }
    exp_route_ar += RT.default_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_id_singu202')
      r[:path] = '/singular/:singular_id' + r[:path].gsub(/\/singular/,'/singu202')
      r[:controller] = 'singu202'
      r }
    exp_route_ar.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.outlaw_resource  [:singular,:plural], :only=>:show, :except=>:new do |inner|
        inner.outlaw_resources :singu201
        inner.outlaw_resource  :singu202
      end ; end
    exp_route_ar = [RT.s_restful_show]
    exp_route_ar += RT.default_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu201')
      r[:path] = '/singular' + r[:path].gsub(/\/singular/,'/singu201')
      r[:controller] = 'singu201'
      r }
    exp_route_ar += RT.s_default_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'singular_singu202')
      r[:path] = '/singular' + r[:path].gsub(/\/singular/,'/singu202')
      r[:controller] = 'singu202'
      r }
    exp_route_ar.should be_exact_routes
    end
  it 'applies :namespace option, to generate routes as if called from within map.namespace' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:singular,:plural], :provide=>:all, :namespace =>'back_office/' }
    RT.all_route_ar.collect   {|orig_r| r = orig_r.dup
      r[:controller] = "back_office/#{r[:controller]}"
      r }.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:singular,:plural], :provide=>:all, :namespace =>'back_office/' }
    RT.s_all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:controller] = "back_office/#{r[:controller]}"
      r }.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resources [:message,:messages], :provide=>:classic, :namespace =>'back_office/' }
    should_have_collec_classics    :message, :messages, :controller=>'back_office/message'
    @scratch_routes.clear! ; @scratch_routes.draw {|map| map.outlaw_resource  [:message,:messages], :provide=>:classic, :namespace =>'back_office/' }
    should_have_singleton_classics :message,            :controller=>'back_office/message'
    end
  it 'applies the :as option without conflict, to create identical path segments in separate namespaces' do
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.outlaw_resources       [:product       ,:products       ], :provide=>:classic do |product|
        product.outlaw_resources [:product_review,:product_reviews], :provide=>:classic, :as=>'review',:controller=>'plur1' ; end
      map.outlaw_resources       [:tutor         ,:tutors         ], :provide=>:classic do |tutor|
        tutor.outlaw_resources   [:tutor_review  ,:tutor_reviews  ], :provide=>:classic, :as=>'review',:controller=>'plur2' ; end
      end
    should_have_collec_classics :product_review, :product_reviews, :controller=>'plur1', :as=>'review', :name_prefix=>'product_', :path_prefix=>'products/1/', :options=>{:product_id=>'1'}
    should_have_collec_classics :tutor_review  , :tutor_reviews  , :controller=>'plur2', :as=>'review', :name_prefix=>'tutor_'  , :path_prefix=>'tutors/1/'  , :options=>{:tutor_id  =>'1'}
    end
  it 'applies many options, and propagates them to :has_many , :has_one , and nested code block' do
    big_opts = {
      :provide=>:all,
      :path_prefix        =>'P',
      :name_prefix        =>'N',
      :id_name_suffix     =>'I',      # Implies :nest_id_name_suffix=>:id_name_suffix
      :root_name_suffix   =>'R',
      :id_root_name_suffix=>'X',
      :has_one=>:singu101,
      :has_many=>:singu102,
      :collection =>{:cget=>:get,              :cput=>:put,:cdel=>:delete},
      :member     =>{:mget=>:get,:mpost=>:post,            :mdel=>:delete},
      :new        =>{            :npost=>:post,:nput=>:put,:ndel=>:delete},
      }
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.outlaw_resources [:singular,:plural], big_opts do |inner|
        inner.outlaw_resource  :singu201
        inner.outlaw_resources :singu202
      end ; end
    [ { :name=>'cget_Nplural' , :verb=>'GET'   ,:path=>"/P/plural#{@a_sep}cget(.:format)",:action=>'cget' ,:controller=>'singular' },
      { :name=>'cput_Nplural' , :verb=>'PUT'   ,:path=>"/P/plural#{@a_sep}cput(.:format)",:action=>'cput' ,:controller=>'singular' },
      { :name=>'cdel_Nplural' , :verb=>'DELETE',:path=>"/P/plural#{@a_sep}cdel(.:format)",:action=>'cdel' ,:controller=>'singular' }
      ].should be_assorted_routes
    exp_route_ar = RT.classic_route_ar.collect {|orig_r| orig_r.dup }
    exp_route_ar.insert_above(RT.classic_show, nil,nil,nil,nil,nil,nil)
    exp_route_ar.collect! {|r| next if r.nil?
      r[:name] = r[:name].gsub(/singular/,'Nsingular').gsub(/plural/,'Nplural')
      r[:path] = "/P#{r[:path]}"
      r }
    exp_route_ar.should be_consecutive_routes
    [ { :name=>'npost_new_Nsingular',:verb=>'POST'  ,:path=>"/P/plural/new#{@a_sep}npost(.:format)",:action=>'npost',:controller=>'singular' },
      { :name=> 'nput_new_Nsingular',:verb=>'PUT'   ,:path=>"/P/plural/new#{@a_sep}nput(.:format)" ,:action=>'nput' ,:controller=>'singular' },
      { :name=> 'ndel_new_Nsingular',:verb=>'DELETE',:path=>"/P/plural/new#{@a_sep}ndel(.:format)" ,:action=>'ndel' ,:controller=>'singular' }
      ].should be_assorted_routes
    [ { :name=> 'mget_Nsingular'    ,:verb=>'GET'   ,:path=>"/P/plural/:id#{@a_sep}mget(.:format)" ,:action=>'mget' ,:controller=>'singular' },
      { :name=>'mpost_Nsingular'    ,:verb=>'POST'  ,:path=>"/P/plural/:id#{@a_sep}mpost(.:format)",:action=>'mpost',:controller=>'singular' },
      { :name=> 'mdel_Nsingular'    ,:verb=>'DELETE',:path=>"/P/plural/:id#{@a_sep}mdel(.:format)" ,:action=>'mdel' ,:controller=>'singular' }
      ].should be_assorted_routes
    [ { :name=>'Nsingular_cget'    ,:verb=>'GET'   ,:path=>"/P/singular#{@a_sep}cget(.:format)"     ,:action=>'cget' ,:controller=>'singular' },
      { :name=>'Nsingular_cput'    ,:verb=>'PUT'   ,:path=>"/P/singular#{@a_sep}cput(.:format)"     ,:action=>'cput' ,:controller=>'singular' },
      { :name=>'Nsingular_cdel'    ,:verb=>'DELETE',:path=>"/P/singular#{@a_sep}cdel(.:format)"     ,:action=>'cdel' ,:controller=>'singular' }
      ].should be_assorted_routes
    exp_route_ar = RT.pretty_plus_restful_route_ar.collect {|orig_r| orig_r.dup } + [
      { :name=>'singular_new_npost',:verb=>'POST'  ,:path=>"/singular/new#{@a_sep}npost(.:format)",:action=>'npost',:controller=>'singular' },
      { :name=>'singular_new_nput' ,:verb=>'PUT'   ,:path=>"/singular/new#{@a_sep}nput(.:format)" ,:action=>'nput' ,:controller=>'singular' },
      { :name=>'singular_new_ndel' ,:verb=>'DELETE',:path=>"/singular/new#{@a_sep}ndel(.:format)" ,:action=>'ndel' ,:controller=>'singular' },
      { :name=>'singular_id_mget'  ,:verb=>'GET'   ,:path=>"/singular/:id/mget(.:format)"         ,:action=>'mget' ,:controller=>'singular' },
      { :name=>'singular_id_mpost' ,:verb=>'POST'  ,:path=>"/singular/:id/mpost(.:format)"        ,:action=>'mpost',:controller=>'singular' },
      { :name=>'singular_id_mdel'  ,:verb=>'DELETE',:path=>"/singular/:id/mdel(.:format)"         ,:action=>'mdel' ,:controller=>'singular' }]
    exp_route_ar.collect! {|r| next if r.nil?
      r[:name] = r[:name].gsub(/_id$/,'_idX').gsub(/_id$/,'_idX').gsub(/_id/,'I').gsub(/singular/,'Nsingular').gsub(/_root/,'R')
      r[:path] = "/P#{r[:path]}"
      r }
    exp_route_ar.should be_assorted_routes
    RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'Nsingular_singu101').gsub(/_root/,'R')
      r[:path] = r[:path].gsub(/singular/,'P/plural/:singular_id/singu101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'NsingularI_singu101').gsub(/_root/,'R')
      r[:path] = r[:path].gsub(/singular/,'P/singular/:singular_id/singu101')
      r[:controller] = 'singu101'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'Nsingular_singu102').gsub(/plural/,'Nsingular_plur102')
      r[:path] = r[:path].gsub(/plural/,'P/plural/:singular_id/plur102')
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'NsingularI_singu102').gsub(/_id$/,'_idX').gsub(/_id$/,'_idX').gsub(/_id/,'I').gsub(/_root/,'R')
      r[:path] = r[:path].gsub(/singular/,'P/singular/:singular_id/singu102')
      r[:controller] = 'singu102'
      r }.should be_consecutive_routes
    RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'Nsingular_singu201').gsub(/_root/,'R')
      r[:path] = r[:path].gsub(/singular/,'P/plural/:singular_id/singu201')
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.s_pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'NsingularI_singu201').gsub(/_root/,'R')
      r[:path] = r[:path].gsub(/singular/,'P/singular/:singular_id/singu201')
      r[:controller] = 'singu201'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'Nsingular_singu202').gsub(/plural/,'Nsingular_plur202')
      r[:path] = r[:path].gsub(/plural/,'P/plural/:singular_id/plur202')
      r[:controller] = 'singu202'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'NsingularI_singu202').gsub(/_id$/,'_idX').gsub(/_id$/,'_idX').gsub(/_id/,'I').gsub(/_root/,'R')
      r[:path] = r[:path].gsub(/singular/,'P/singular/:singular_id/singu202')
      r[:controller] = 'singu202'
      r }.should be_consecutive_routes
    end
  end # describe

describe ResourcesController, 'a call to outlaw_resources() or _resource() in a code block sent to map.namespace()', :type=>:controller do
  before :all  do before_all ; end
  before :each do before_each ; end
  after  :each do after_each ; end
  after  :all  do after_all ; end
  it 'prepends the namespace identifier to the controller, route names, and URL paths' do
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.outlaw_resources [:singular,:plural], :provide=>:all
      end ; end
    RT.all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'back_office_singular').gsub(/plural/,'back_office_plural')
      r[:path] = "/back_office#{r[:path]}"
      r[:controller] = 'back_office/singular'
      r }.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.outlaw_resource  [:singular,:plural], :provide=>:all
      end ; end
    RT.s_all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'back_office_singular')
      r[:path] = "/back_office#{r[:path]}"
      r[:controller] = 'back_office/singular'
      r }.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.outlaw_resources [:product,:products], :provide=>[:classic]
      end ; end
    should_have_collec_classics    :product, :products, :controller=>'back_office/product', :name_prefix=>'back_office_', :path_prefix=>'back_office/'
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.outlaw_resource  [:product,:products], :provide=>[:classic]
      end ; end
    should_have_singleton_classics :product,            :controller=>'back_office/product', :name_prefix=>'back_office_', :path_prefix=>'back_office/'
    end
  it "applies :has_many=>(Symbol or String) option, to add a nested collection" do
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.outlaw_resources [:singular,:plural], :provide=>:all, :has_many=>'singu101'
      end ; end
    exp_route_ar = RT.all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'back_office_singular').gsub(/plural/,'back_office_plural')
      r[:path] = "/back_office#{r[:path]}"
      r[:controller] = 'back_office/singular'
      r }
    exp_route_ar += RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'back_office_singular_singu101').gsub(/plural/,'back_office_singular_plur101')
      r[:path] = r[:path].gsub(/plural/,'back_office/plural/:singular_id/plur101')
      r[:controller] = 'back_office/singu101'
      r }
    exp_route_ar += RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'back_office_singular_id_singu101')
      r[:path] = r[:path].gsub(/singular/,'back_office/singular/:singular_id/singu101')
      r[:controller] = 'back_office/singu101'
      r }
    exp_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.outlaw_resource  [:singular,:plural], :provide=>:all, :has_many=>'singu101'
      end ; end
    exp_route_ar = RT.s_all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'back_office_singular')
      r[:path] = "/back_office#{r[:path]}"
      r[:controller] = 'back_office/singular'
      r }
    exp_route_ar += RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'back_office_singular_singu101').gsub(/plural/,'back_office_singular_plur101')
      r[:path] = r[:path].gsub(/plural/,'back_office/singular/plur101')
      r[:controller] = 'back_office/singu101'
      r }
    exp_route_ar += RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'back_office_singular_singu101')
      r[:path] = r[:path].gsub(/singular/,'back_office/singular/singu101')
      r[:controller] = 'back_office/singu101'
      r }
    exp_route_ar.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.outlaw_resources [:product,:products], :provide=>:classic, :has_many=>:singu101
      end ; end
      should_have_collec_classics    :product , :products, :controller=>'back_office/product' , :name_prefix=>'back_office_'        , :path_prefix=>'back_office/'
      should_have_collec_classics    :singu101, :plur101 , :controller=>'back_office/singu101', :name_prefix=>'back_office_product_', :path_prefix=>'back_office/products/1/', :options=>{:product_id=>'1'}
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.outlaw_resource  [:product,:products], :provide=>:classic, :has_many=>:singu101
      end ; end
      should_have_singleton_classics :product ,            :controller=>'back_office/product' , :name_prefix=>'back_office_'        , :path_prefix=>'back_office/'
      should_have_collec_classics    :singu101, :plur101 , :controller=>'back_office/singu101', :name_prefix=>'back_office_product_', :path_prefix=>'back_office/product/'
      end
  it 'applies :has_one=>(Symbol or String) option' do
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.outlaw_resources [:singular,:plural], :provide=>:all, :has_one=>:singu101
      end ; end
    exp_route_ar = RT.all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'back_office_singular').gsub(/plural/,'back_office_plural')
      r[:path] = "/back_office#{r[:path]}"
      r[:controller] = 'back_office/singular'
      r }
    exp_route_ar += RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'back_office_singular_singu101')
      r[:path] = r[:path].gsub(/singular/,'back_office/plural/:singular_id/singu101')
      r[:controller] = 'back_office/singu101'
      r }
    exp_route_ar += RT.s_pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'back_office_singular_id_singu101')
      r[:path] = r[:path].gsub(/singular/,'back_office/singular/:singular_id/singu101')
      r[:controller] = 'back_office/singu101'
      r }
    exp_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.outlaw_resource  [:singular,:plural], :provide=>:all, :has_one=>:singu101
      end ; end
    exp_route_ar = RT.s_all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'back_office_singular')
      r[:path] = "/back_office#{r[:path]}"
      r[:controller] = 'back_office/singular'
      r }
    exp_route_ar += RT.s_classic_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'back_office_singular_singu101')
      r[:path] = r[:path].gsub(/singular/,'back_office/singular/singu101')
      r[:controller] = 'back_office/singu101'
      r }
    exp_route_ar += RT.s_pretty_plus_restful_route_ar.but_without(*RT.s_restful_c_u_d_ar).collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'back_office_singular_singu101')
      r[:path] = r[:path].gsub(/singular/,'back_office/singular/singu101')
      r[:controller] = 'back_office/singu101'
      r }
    exp_route_ar.should be_exact_routes

    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.outlaw_resources [:product,:products], :provide=>:classic, :has_one=>:singu101
      end ; end
      should_have_collec_classics    :product, :products, :controller=>'back_office/product' , :name_prefix=>'back_office_'        , :path_prefix=>'back_office/'
      should_have_singleton_classics :singu101,           :controller=>'back_office/singu101', :name_prefix=>'back_office_product_', :path_prefix=>'back_office/products/1/', :options=>{:product_id=>'1'}
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.outlaw_resource  [:product,:products], :provide=>:classic, :has_one=>:singu101
      end ; end
      should_have_singleton_classics :product,            :controller=>'back_office/product' , :name_prefix=>'back_office_'        , :path_prefix=>'back_office/'
      should_have_singleton_classics :singu101,           :controller=>'back_office/singu101', :name_prefix=>'back_office_product_', :path_prefix=>'back_office/product/'
    end
  it 'nests within another level of namespace() code block, to add an additional level of namespace' do
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.namespace :admin do |admin|
          admin.outlaw_resources [:product,:products], :provide=>:classic
      end ; end ; end
    should_have_collec_classics :product, :products, :controller=>'back_office/admin/product', :name_prefix=>'back_office_admin_', :path_prefix=>'back_office/admin/'
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.namespace :admin do |admin|
          admin.outlaw_resource  [:product,:products], :provide=>:classic
      end ; end ; end
    should_have_singleton_classics :product,         :controller=>'back_office/admin/product', :name_prefix=>'back_office_admin_', :path_prefix=>'back_office/admin/'
    end
  it 'receives a code block containing outlaw_resources() , to add a nested collection' do
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.outlaw_resources [:product,:products], :provide=>:classic do |product|
          product.outlaw_resources   [:image,:images]    , :provide=>:classic
      end ; end ; end
    should_have_collec_classics    :product, :products, :controller=>'back_office/product', :name_prefix=>'back_office_'        , :path_prefix=>'back_office/'
    should_have_collec_classics    :image  , :images  , :controller=>'back_office/image'  , :name_prefix=>'back_office_product_', :path_prefix=>'back_office/products/1/', :options=>{:product_id=>'1'}
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.outlaw_resource  [:product,:products], :provide=>:classic do |product|
          product.outlaw_resources   [:image,:images]    , :provide=>:classic
      end ; end ; end
    should_have_singleton_classics :product,            :controller=>'back_office/product', :name_prefix=>'back_office_'        , :path_prefix=>'back_office/'
    should_have_collec_classics    :image  , :images  , :controller=>'back_office/image'  , :name_prefix=>'back_office_product_', :path_prefix=>'back_office/product/'
    end
  it 'receives a code block containing outlaw_resource() , to add a nested singleton' do
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.outlaw_resources [:product,:products], :provide=>:classic do |product|
          product.outlaw_resource    [:image,:images]    , :provide=>:classic
      end ; end ; end
    should_have_collec_classics    :product, :products, :controller=>'back_office/product', :name_prefix=>'back_office_'        , :path_prefix=>'back_office/'
    should_have_singleton_classics :image  ,            :controller=>'back_office/image'  , :name_prefix=>'back_office_product_', :path_prefix=>'back_office/products/1/', :options=>{:product_id=>'1'}
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.outlaw_resource  [:product,:products], :provide=>:classic do |product|
          product.outlaw_resource    [:image,:images]    , :provide=>:classic
      end ; end ; end
    should_have_singleton_classics :product,            :controller=>'back_office/product', :name_prefix=>'back_office_'        , :path_prefix=>'back_office/'
    should_have_singleton_classics :image  ,            :controller=>'back_office/image'  , :name_prefix=>'back_office_product_', :path_prefix=>'back_office/product/'
    end
  it 'nests within another level of namespace() code block and receives an outlaw_resources() block' do
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.namespace :admin do |admin|
          admin.outlaw_resources [:product,:products], :provide=>:classic do |product|
            product.outlaw_resources [:image,:images], :provide=>:classic
      end ; end ; end ; end
    should_have_collec_classics    :product, :products, :controller=>'back_office/admin/product', :name_prefix=>'back_office_admin_'        , :path_prefix=>'back_office/admin/'
    should_have_collec_classics    :image  , :images  , :controller=>'back_office/admin/image'  , :name_prefix=>'back_office_admin_product_', :path_prefix=>'back_office/admin/products/1/', :options=>{:product_id=>'1'}
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.namespace :admin do |admin|
          admin.outlaw_resource  [:product,:products], :provide=>:classic do |product|
            product.outlaw_resources [:image,:images], :provide=>:classic
      end ; end ; end ; end
    should_have_singleton_classics :product,            :controller=>'back_office/admin/product', :name_prefix=>'back_office_admin_'        , :path_prefix=>'back_office/admin/'
    should_have_collec_classics    :image  , :images  , :controller=>'back_office/admin/image'  , :name_prefix=>'back_office_admin_product_', :path_prefix=>'back_office/admin/product/'
    end
  it 'nests within another level of namespace() code block and receives an outlaw_resource() block' do
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.namespace :admin do |admin|
          admin.outlaw_resources [:product,:products], :provide=>:classic do |product|
            product.outlaw_resource  [:image,:images], :provide=>:classic
      end ; end ; end ; end
    should_have_collec_classics    :product, :products, :controller=>'back_office/admin/product', :name_prefix=>'back_office_admin_'        , :path_prefix=>'back_office/admin/'
    should_have_singleton_classics :image  ,            :controller=>'back_office/admin/image'  , :name_prefix=>'back_office_admin_product_', :path_prefix=>'back_office/admin/products/1/', :options=>{:product_id=>'1'}
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.namespace :admin do |admin|
          admin.outlaw_resource  [:product,:products], :provide=>:classic do |product|
            product.outlaw_resource  [:image,:images], :provide=>:classic
      end ; end ; end ; end
    should_have_singleton_classics :product,            :controller=>'back_office/admin/product', :name_prefix=>'back_office_admin_'        , :path_prefix=>'back_office/admin/'
    should_have_singleton_classics :image  ,            :controller=>'back_office/admin/image'  , :name_prefix=>'back_office_admin_product_', :path_prefix=>'back_office/admin/product/'
    end
  it 'nested resources inherit and properly apply the :shallow option, while themselves nested within namespaces' do
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      map.namespace :back_office do |back_office|
        back_office.namespace :admin do |admin|
          admin.outlaw_resources [:product,:products], :provide=>:all, :shallow=>true do |product|
            product.outlaw_resources [:image,:images], :provide=>:all
      end ; end ; end ; end
    RT.all_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'back_office_admin_product').gsub(/plural/,'back_office_admin_products')
      r[:path] = "/back_office/admin#{r[:path]}".gsub(/singular/,'product').gsub(/plural/,'products')
      r[:controller] = 'back_office/admin/product'
      r }.should be_consecutive_routes
    RT.classic_route_ar.collect {|orig_r| r = orig_r.dup
      if r[:path] =~/:id/
        r[:name] = r[:name].gsub(/singular/,'back_office_admin_image').gsub(/plural/,'back_office_admin_images')
      else
        r[:name] = r[:name].gsub(/singular/,'back_office_admin_product_image').gsub(/plural/,'back_office_admin_product_images')
        r[:path] = "/products/:product_id#{r[:path]}"
        end
      r[:path] = "/back_office/admin#{r[:path]}".gsub(/singular/,'image').gsub(/plural/,'images')
      r[:controller] = 'back_office/admin/image'
      r }.should be_consecutive_routes
    RT.pretty_plus_restful_route_ar.collect {|orig_r| r = orig_r.dup
      if r[:path] =~/:id/
        r[:name] = r[:name].gsub(/singular/,'back_office_admin_image')
      else
        r[:name] = r[:name].gsub(/singular/,'back_office_admin_product_id_image')
        r[:path] = "/product/:product_id#{r[:path]}"
        end
      r[:path] = "/back_office/admin#{r[:path]}".gsub(/singular/,'image')
      r[:controller] = 'back_office/admin/image'
      r }.should be_consecutive_routes
    end
  end # describe

describe ResourcesController, 'dry-mapping resource route collection methods', :type=>:controller do
  before :all  do before_all ; end
  before :each do before_each ; end
  after  :each do after_each ; end
  after  :all  do after_all ; end
  it 'outlaw_resource(s)_descriptor_array methods return an array of route descriptor hashes, without actually mapping any routes' do
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      collection_ar = map.outlaw_resources_descriptor_array([:singular,:plural], :provide=>:restful, :requirements=>{:id=>/abc/} )
      singleton_ar  = map.outlaw_resource_descriptor_array( [:singular,:plural], :provide=>:restful )
      collection_ar.should == [
        {:name=>'singular_root',    :path=>'/singular.:format'         ,:options=>{:action=>'index'  ,:controller=>'singular',:conditions=>{:method=>:get   }           }},
        {                           :path=>'/singular.:format'         ,:options=>{:action=>'create' ,:controller=>'singular',:conditions=>{:method=>:post  }           }},
        {:name=>'singular_new',     :path=>'/singular/new.:format'     ,:options=>{:action=>'new'    ,:controller=>'singular',:conditions=>{:method=>:get   }           }},
        {:name=>'singular_id',      :path=>'/singular/:id.:format'     ,:options=>{:action=>'show'   ,:controller=>'singular',:conditions=>{:method=>:get   },:id=>/abc/}},
        {                           :path=>'/singular/:id.:format'     ,:options=>{:action=>'update' ,:controller=>'singular',:conditions=>{:method=>:put   },:id=>/abc/}},
        {                           :path=>'/singular/:id.:format'     ,:options=>{:action=>'destroy',:controller=>'singular',:conditions=>{:method=>:delete},:id=>/abc/}},
        {:name=>'singular_id_edit', :path=>'/singular/:id/edit.:format',:options=>{:action=>'edit'   ,:controller=>'singular',:conditions=>{:method=>:get   },:id=>/abc/}}]
      singleton_ar.should == [
        {:name=>'singular_new',     :path=>'/singular/new.:format' ,:options=>{:action=>'new'    ,:controller=>'singular',:conditions=>{:method=>:get   } }},
        {:name=>'singular_root',    :path=>'/singular.:format'     ,:options=>{:action=>'show'   ,:controller=>'singular',:conditions=>{:method=>:get   } }},
        {                           :path=>'/singular.:format'     ,:options=>{:action=>'create' ,:controller=>'singular',:conditions=>{:method=>:post  } }},
        {                           :path=>'/singular.:format'     ,:options=>{:action=>'update' ,:controller=>'singular',:conditions=>{:method=>:put   } }},
        {                           :path=>'/singular.:format'     ,:options=>{:action=>'destroy',:controller=>'singular',:conditions=>{:method=>:delete} }},
        {:name=>'singular_edit',    :path=>'/singular/edit.:format',:options=>{:action=>'edit'   ,:controller=>'singular',:conditions=>{:method=>:get   } }}]
      end
    [].should be_exact_routes
    end
  it 'outlaw_resource(s)_descriptor_array methods can receive code blocks containing nested calls to outlaw_resources() and outlaw_resource()' do
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      nested_c_ar = map.outlaw_resources_descriptor_array( :article, :provide=>:restful, :requirements=>{:id=>/abc/} ) do |article|
                      article.outlaw_resources(            :thread , :provide=>:restful, :requirements=>{:id=>/abc/} ) do |thread|
                        thread.outlaw_resources(           :comment, :provide=>:restful, :requirements=>{:id=>/abc/} )
        end ; end
      nested_s_ar = map.outlaw_resource_descriptor_array(  :outer  , :provide=>:restful, :requirements=>{:id=>/abc/} ) do |outer|
                      outer.outlaw_resource(               :middle , :provide=>:restful, :requirements=>{:id=>/abc/} ) do |middle|
                        middle.outlaw_resource(            :inner  , :provide=>:restful, :requirements=>{:id=>/abc/} )
        end ; end
      nested_c_ar.should == [
        {:name=>"article_root",                        :path=>"/article.:format"                                               ,:options=>{:controller=>"article",:conditions=>{:method=>:get   },:action=>"index"             }},
        {                                              :path=>"/article.:format"                                               ,:options=>{:controller=>"article",:conditions=>{:method=>:post  },:action=>"create"            }},
        {:name=>"article_new",                         :path=>"/article/new.:format"                                           ,:options=>{:controller=>"article",:conditions=>{:method=>:get   },:action=>"new"               }},
        {:name=>"article_id",                          :path=>"/article/:id.:format"                                           ,:options=>{:controller=>"article",:conditions=>{:method=>:get   },:action=>"show"   ,:id=>/abc/}},
        {                                              :path=>"/article/:id.:format"                                           ,:options=>{:controller=>"article",:conditions=>{:method=>:put   },:action=>"update" ,:id=>/abc/}},
        {                                              :path=>"/article/:id.:format"                                           ,:options=>{:controller=>"article",:conditions=>{:method=>:delete},:action=>"destroy",:id=>/abc/}},
        {:name=>"article_id_edit",                     :path=>"/article/:id/edit.:format"                                      ,:options=>{:controller=>"article",:conditions=>{:method=>:get   },:action=>"edit"   ,:id=>/abc/}},
        {:name=>"article_id_thread_root",              :path=>"/article/:article_id/thread.:format"                            ,:options=>{:controller=>"thread" ,:conditions=>{:method=>:get   },:action=>"index"             }},
        {                                              :path=>"/article/:article_id/thread.:format"                            ,:options=>{:controller=>"thread" ,:conditions=>{:method=>:post  },:action=>"create"            }},
        {:name=>"article_id_thread_new",               :path=>"/article/:article_id/thread/new.:format"                        ,:options=>{:controller=>"thread" ,:conditions=>{:method=>:get   },:action=>"new"               }},
        {:name=>"article_id_thread_id",                :path=>"/article/:article_id/thread/:id.:format"                        ,:options=>{:controller=>"thread" ,:conditions=>{:method=>:get   },:action=>"show"   ,:id=>/abc/}},
        {                                              :path=>"/article/:article_id/thread/:id.:format"                        ,:options=>{:controller=>"thread" ,:conditions=>{:method=>:put   },:action=>"update" ,:id=>/abc/}},
        {                                              :path=>"/article/:article_id/thread/:id.:format"                        ,:options=>{:controller=>"thread" ,:conditions=>{:method=>:delete},:action=>"destroy",:id=>/abc/}},
        {:name=>"article_id_thread_id_edit",           :path=>"/article/:article_id/thread/:id/edit.:format"                   ,:options=>{:controller=>"thread" ,:conditions=>{:method=>:get   },:action=>"edit"   ,:id=>/abc/}},
        {:name=>"article_id_thread_id_comment_root",   :path=>"/article/:article_id/thread/:thread_id/comment.:format"         ,:options=>{:controller=>"comment",:conditions=>{:method=>:get   },:action=>"index"             }},
        {                                              :path=>"/article/:article_id/thread/:thread_id/comment.:format"         ,:options=>{:controller=>"comment",:conditions=>{:method=>:post  },:action=>"create"            }},
        {:name=>"article_id_thread_id_comment_new",    :path=>"/article/:article_id/thread/:thread_id/comment/new.:format"     ,:options=>{:controller=>"comment",:conditions=>{:method=>:get   },:action=>"new"               }},
        {:name=>"article_id_thread_id_comment_id",     :path=>"/article/:article_id/thread/:thread_id/comment/:id.:format"     ,:options=>{:controller=>"comment",:conditions=>{:method=>:get   },:action=>"show"   ,:id=>/abc/}},
        {                                              :path=>"/article/:article_id/thread/:thread_id/comment/:id.:format"     ,:options=>{:controller=>"comment",:conditions=>{:method=>:put   },:action=>"update" ,:id=>/abc/}},
        {                                              :path=>"/article/:article_id/thread/:thread_id/comment/:id.:format"     ,:options=>{:controller=>"comment",:conditions=>{:method=>:delete},:action=>"destroy",:id=>/abc/}},
        {:name=>"article_id_thread_id_comment_id_edit",:path=>"/article/:article_id/thread/:thread_id/comment/:id/edit.:format",:options=>{:controller=>"comment",:conditions=>{:method=>:get   },:action=>"edit"   ,:id=>/abc/}}]
      nested_s_ar.should == [
        {:name=>"outer_new",               :path=>"/outer/new.:format"              ,:options=>{:controller=>"outer" ,:conditions=>{:method=>:get   },:action=>"new"    }},
        {:name=>"outer_root",              :path=>"/outer.:format"                  ,:options=>{:controller=>"outer" ,:conditions=>{:method=>:get   },:action=>"show"   }},
        {                                  :path=>"/outer.:format"                  ,:options=>{:controller=>"outer" ,:conditions=>{:method=>:post  },:action=>"create" }},
        {                                  :path=>"/outer.:format"                  ,:options=>{:controller=>"outer" ,:conditions=>{:method=>:put   },:action=>"update" }},
        {                                  :path=>"/outer.:format"                  ,:options=>{:controller=>"outer" ,:conditions=>{:method=>:delete},:action=>"destroy"}},
        {:name=>"outer_edit",              :path=>"/outer/edit.:format"             ,:options=>{:controller=>"outer" ,:conditions=>{:method=>:get   },:action=>"edit"   }},
        {:name=>"outer_middle_new",        :path=>"/outer/middle/new.:format"       ,:options=>{:controller=>"middle",:conditions=>{:method=>:get   },:action=>"new"    }},
        {:name=>"outer_middle_root",       :path=>"/outer/middle.:format"           ,:options=>{:controller=>"middle",:conditions=>{:method=>:get   },:action=>"show"   }},
        {                                  :path=>"/outer/middle.:format"           ,:options=>{:controller=>"middle",:conditions=>{:method=>:post  },:action=>"create" }},
        {                                  :path=>"/outer/middle.:format"           ,:options=>{:controller=>"middle",:conditions=>{:method=>:put   },:action=>"update" }},
        {                                  :path=>"/outer/middle.:format"           ,:options=>{:controller=>"middle",:conditions=>{:method=>:delete},:action=>"destroy"}},
        {:name=>"outer_middle_edit",       :path=>"/outer/middle/edit.:format"      ,:options=>{:controller=>"middle",:conditions=>{:method=>:get   },:action=>"edit"   }},
        {:name=>"outer_middle_inner_new",  :path=>"/outer/middle/inner/new.:format" ,:options=>{:controller=>"inner" ,:conditions=>{:method=>:get   },:action=>"new"    }},
        {:name=>"outer_middle_inner_root", :path=>"/outer/middle/inner.:format"     ,:options=>{:controller=>"inner" ,:conditions=>{:method=>:get   },:action=>"show"   }},
        {                                  :path=>"/outer/middle/inner.:format"     ,:options=>{:controller=>"inner" ,:conditions=>{:method=>:post  },:action=>"create" }},
        {                                  :path=>"/outer/middle/inner.:format"     ,:options=>{:controller=>"inner" ,:conditions=>{:method=>:put   },:action=>"update" }},
        {                                  :path=>"/outer/middle/inner.:format"     ,:options=>{:controller=>"inner" ,:conditions=>{:method=>:delete},:action=>"destroy"}},
        {:name=>"outer_middle_inner_edit", :path=>"/outer/middle/inner/edit.:format",:options=>{:controller=>"inner" ,:conditions=>{:method=>:get   },:action=>"edit"   }}]
      end
    [].should be_exact_routes
    end
  it 'outlaw_resource(s)_ruby_code_array methods return an array of "named_route(" and "connect(" Ruby code fragments' do
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      line_ar = map.outlaw_resources_ruby_code_array( [:singular,:plural], :provide=>:restful, :requirements=>{:id=>/abc/} )
        line_ar.size.should == 7
        [ 'named_route("singular_root","/singular.:format",{',
          'connect("/singular.:format",{',
          'named_route("singular_new","/singular/new.:format",{',
          'named_route("singular_id","/singular/:id.:format",{',
          'connect("/singular/:id.:format",{',
          'connect("/singular/:id.:format",{',
          'named_route("singular_id_edit","/singular/:id/edit.:format",{'
          ].each_with_index {|x,i| line_ar[i].gsub(' ','')[0...x.length].should == x }
        ruby_code = line_ar.collect {|frag| "map.#{frag}\n" }.join
        [].should be_exact_routes
        eval(ruby_code)
      end
    RT.restful_route_ar.should be_exact_routes
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      line_ar = map.outlaw_resource_ruby_code_array( [:singular,:plural], :provide=>:restful )
        line_ar.size.should == 6
        [ 'named_route("singular_new","/singular/new.:format",{',
          'named_route("singular_root","/singular.:format",{',
          'connect("/singular.:format",{',
          'connect("/singular.:format",{',
          'connect("/singular.:format",{',
          'named_route("singular_edit","/singular/edit.:format",{'
          ].each_with_index {|x,i| line_ar[i].gsub(' ','')[0...x.length].should == x }
        ruby_code = line_ar.collect {|frag| "map.#{frag}\n" }.join
        [].should be_exact_routes
        eval(ruby_code)
      end
    RT.s_restful_route_ar.should be_exact_routes
    end
  it 'outlaw_resource(s)_ruby_code_array methods can receive codeblocks containing nested calls to outlaw_resources() and outlaw_resource()' do
    @scratch_routes.clear! ; @scratch_routes.draw do |map|
      nested_c_ruby_ar = map.outlaw_resources_ruby_code_array( :article, :provide=>:restful, :requirements=>{:id=>/abc/} ) do |article|
                           article.outlaw_resources(           :thread , :provide=>:restful, :requirements=>{:id=>/abc/} ) do |thread|
                             thread.outlaw_resources(          :comment, :provide=>:restful, :requirements=>{:id=>/abc/} )
        end ; end
      nested_s_ruby_ar = map.outlaw_resource_ruby_code_array( :outer  , :provide=>:restful, :requirements=>{:id=>/abc/} ) do |outer|
                           outer.outlaw_resource(             :middle , :provide=>:restful, :requirements=>{:id=>/abc/} ) do |middle|
                             middle.outlaw_resource(          :inner  , :provide=>:restful, :requirements=>{:id=>/abc/} )
        end ; end
      ruby_code = (nested_c_ruby_ar+nested_s_ruby_ar).collect {|frag| "map.#{frag}\n" }.join
      [].should be_exact_routes
      eval(ruby_code)
      end
    exp_route_ar  = RT.restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'article')
      r[:path] = r[:path].gsub(/singular/,'article')
      r[:controller] = 'article'
      r }
    exp_route_ar += RT.restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'article_id_thread')
      r[:path] = r[:path].gsub(/singular/,'article/:article_id/thread')
      r[:controller] = 'thread'
      r }
    exp_route_ar += RT.restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'article_id_thread_id_comment')
      r[:path] = r[:path].gsub(/singular/,'article/:article_id/thread/:thread_id/comment')
      r[:controller] = 'comment'
      r }
    exp_route_ar += RT.s_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'outer')
      r[:path] = r[:path].gsub(/singular/,'outer')
      r[:controller] = 'outer'
      r }
    exp_route_ar += RT.s_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'outer_middle')
      r[:path] = r[:path].gsub(/singular/,'outer/middle')
      r[:controller] = 'middle'
      r }
    exp_route_ar += RT.s_restful_route_ar.collect {|orig_r| r = orig_r.dup
      r[:name] = r[:name].gsub(/singular/,'outer_middle_inner')
      r[:path] = r[:path].gsub(/singular/,'outer/middle/inner')
      r[:controller] = 'inner'
      r }
    exp_route_ar.should be_exact_routes
    end
  it 'map_from_route_descriptor_array() maps routes from an array, including :requirements option' do
    @scratch_routes.clear! ; @scratch_routes.draw {|map|
      rdescr_ar = map.outlaw_resources_descriptor_array [:singular,:plural], :provide=>:all, :requirements=>{:id=>/[0-9]\.[0-9]\.[0-9]/}
      [].should be_exact_routes
      map.map_from_route_descriptor_array(rdescr_ar)
      }
    expec_options = {:controller=>'singular',:action=>'show',:id=>'1.1.1'}
    should_recognize expec_options, :path=>'plural/1.1.1'  ,:method=>:get
    RT.all_route_ar.should be_exact_routes
    end
  end # describe
