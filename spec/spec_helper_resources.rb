# This script provides code for testing lib/resources.rb and tools/syntax_suggester.rb

require "#{File.dirname(__FILE__)}/spec_helper_all"
# ActiveRecord::Base.logger = Logger.new("#{plugin_spec_dir}/debug.log")

# Debugging helper:
class Array
  def shr
    n_wid = 6 ; self.each {|r| return 'Not a route array' unless r.is_a?(Hash) && r.has_key?(:path)
      n_wid = n_wid.not_below(r[:name].to_s.length) }
    self.each {|r| puts r.nil? ? "(nil)\n" : "#{r[:name].to_s.rjust(n_wid)} #{r[:verb].to_s.ljust(7)}#{r[:path].to_s}\n" }.size
    end
  end

class Array
  def but_without(*val_ar) reject {|v| val_ar.include?(v) } ; end
  def insert_above(val,*payload_ar) insert(index(val), *payload_ar) ; end
  def nil_out_at(*val_ar) val_ar.each {|v| self[index(v)] = nil } ; self ; end
  end

# This script disables the Inflector, causing everything to pluralize as itself,
# and everything to singularize as itself, with a few exceptions. The words
# 'singular' and 'plural' are only expected to be used in contexts where they
# are never asked to pluralize or singularize implicitly. So the inflector is
# loaded with some ridiculous inflections of them, which are not expected to ever
# be used in code, only to flag attention if they appear. Words beginning with
# 'singu' and ending in numerics are the singular form of words beginning
# with 'plur' and ending in the same numeric sequence, and vice-versa. This
# allows detection of errors caused by reliance on Inflector behavior.
ActiveSupport::Inflector.inflections do |inflect|
  inflect.plural   /^(.*)$/, '\1'
  inflect.singular /^(.*)$/, '\1'
  inflect.plural   /singular/, 'pluralizedSingular'
  inflect.singular /singular/, 'singularizedSingular'
  inflect.plural   /plural/  , 'pluralizedPlural'
  inflect.singular /plural/  , 'singularizedPlural'
  inflect.plural /^singu(\d+)$/, 'plur\1'
  inflect.singular /^plur(\d+)$/, 'singu\1'
  end

class ResourcesController < ActionController::Base
  def rescue_action(e) raise e end
  def index() render :nothing=>true end
  alias_method :show, :index
  end
class ThreadController < ResourcesController ; end
class MessageController < ResourcesController ; end
class CommentController < ResourcesController ; end
class AccountController < ResourcesController ; end
class AdminController < ResourcesController ; end
class Plur1Controller < ResourcesController ; end
class Plur2Controller < ResourcesController ; end
class Plur3Controller < ResourcesController ; end
class Singu101Controller < ResourcesController ; end
class Singu102Controller < ResourcesController ; end
class Singu103Controller < ResourcesController ; end
class Singu104Controller < ResourcesController ; end
class Singu105Controller < ResourcesController ; end
class Singu106Controller < ResourcesController ; end
class SingularController < ResourcesController ; end
module BackOffice
  class ProductController < ResourcesController ; end
  class MessageController < ResourcesController ; end
  class Plur1Controller < ResourcesController ; end
  class Singu101Controller < ResourcesController ; end
  class ImageController < ResourcesController ; end
  module Admin
    class ProductController < ResourcesController ; end
    class ImageController < ResourcesController ; end
  end ; end

def before_all
  @orig_routes = ActionController::Routing::Routes
  @orig_optim  = ActionController::Base.optimise_named_routes
  ActionController::Routing.module_eval { remove_const :Routes } if ActionController::Routing.const_defined?(:Routes)
  end
def before_each
  @scratch_routes = ActionController::Routing::RouteSet.new
  @a_sep          = ActionController::Base.resource_action_separator
  @controller     = nil
  ActionController::Base.optimise_named_routes = false
  ActionController::Routing.const_set(:Routes, @scratch_routes)
  end
def after_each
  ActionController::Routing.module_eval { remove_const :Routes }
  ActionController::Base.optimise_named_routes = true
  end
def after_all
  ActionController::Routing.const_set(:Routes, @orig_routes) # if @orig_routes
  ActionController::Base.optimise_named_routes = @orig_optim
  end

# A class of standardized route descriptor data, for purposes of testing.
class RouteTester

  # Build route descriptors for individual routes.
  # The routes presented here are what would be expected to be generated by the syntax:
  #   map.outlaw_resources [:singular,:plural]
  #       or
  #   map.outlaw_resource :singular
  #       with the appropriate :provide option, and otherwise default options.
  # "s_" = "singleton resource, as in outlaw_resource() as opposed to outlaw_resources()
  a_sep = ActionController::Base.resource_action_separator
  @@classic_index    = { :name=>            'plural' ,:verb=>'GET'   ,:path=>"/plural(.:format)"                      ,:action=>'index'  ,:controller=>'singular' }.freeze
  @@classic_create   = { :name=>                  '' ,:verb=>'POST'  ,:path=>"/plural(.:format)"                      ,:action=>'create' ,:controller=>'singular' }.freeze
  @@classic_new      = { :name=>      'new_singular' ,:verb=>'GET'   ,:path=>"/plural/new(.:format)"                  ,:action=>'new'    ,:controller=>'singular' }.freeze
  @@classic_show     = { :name=>          'singular' ,:verb=>'GET'   ,:path=>"/plural/:id(.:format)"                  ,:action=>'show'   ,:controller=>'singular' }.freeze
  @@classic_update   = { :name=>                  '' ,:verb=>'PUT'   ,:path=>"/plural/:id(.:format)"                  ,:action=>'update' ,:controller=>'singular' }.freeze
  @@classic_destroy  = { :name=>                  '' ,:verb=>'DELETE',:path=>"/plural/:id(.:format)"                  ,:action=>'destroy',:controller=>'singular' }.freeze
  @@classic_edit     = { :name=>     'edit_singular' ,:verb=>'GET'   ,:path=>"/plural/:id#{a_sep}edit(.:format)"      ,:action=>'edit'   ,:controller=>'singular' }.freeze
  @@restful_index    = { :name=>'singular_root'      ,:verb=>'GET'   ,:path=>"/singular(.:format)"                    ,:action=>'index'  ,:controller=>'singular' }.freeze
  @@restful_create   = { :name=>''                   ,:verb=>'POST'  ,:path=>"/singular(.:format)"                    ,:action=>'create' ,:controller=>'singular' }.freeze
  @@restful_new      = { :name=>'singular_new'       ,:verb=>'GET'   ,:path=>"/singular/new(.:format)"                ,:action=>'new'    ,:controller=>'singular' }.freeze
  @@restful_show     = { :name=>'singular_id'        ,:verb=>'GET'   ,:path=>"/singular/:id(.:format)"                ,:action=>'show'   ,:controller=>'singular' }.freeze
  @@restful_update   = { :name=>''                   ,:verb=>'PUT'   ,:path=>"/singular/:id(.:format)"                ,:action=>'update' ,:controller=>'singular' }.freeze
  @@restful_destroy  = { :name=>''                   ,:verb=>'DELETE',:path=>"/singular/:id(.:format)"                ,:action=>'destroy',:controller=>'singular' }.freeze
  @@restful_edit     = { :name=>'singular_id_edit'   ,:verb=>'GET'   ,:path=>"/singular/:id#{a_sep}edit(.:format)"    ,:action=>'edit'   ,:controller=>'singular' }.freeze
  @@pretty_index     = { :name=>'singular_index'     ,:verb=>'GET'   ,:path=>"/singular/index(.:format)"              ,:action=>'index'  ,:controller=>'singular' }.freeze
  @@pretty_create    = { :name=>'singular_create'    ,:verb=>'POST'  ,:path=>"/singular/create(.:format)"             ,:action=>'create' ,:controller=>'singular' }.freeze
  @@pretty_new       = @@restful_new # When two route are identical, classic trumps non-classic and restful trumps pretty.
  @@pretty_show      = { :name=>'singular_id_show'   ,:verb=>'GET'   ,:path=>"/singular/:id#{a_sep}show(.:format)"    ,:action=>'show'   ,:controller=>'singular' }.freeze
  @@pretty_update    = { :name=>'singular_id_update' ,:verb=>'PUT'   ,:path=>"/singular/:id#{a_sep}update(.:format)"  ,:action=>'update' ,:controller=>'singular' }.freeze
  @@pretty_destroy   = { :name=>'singular_id_destroy',:verb=>'DELETE',:path=>"/singular/:id#{a_sep}destroy(.:format)" ,:action=>'destroy',:controller=>'singular' }.freeze
  @@pretty_edit      = @@restful_edit
  @@s_classic_new    = { :name=>      'new_singular' ,:verb=>'GET'   ,:path=>"/singular/new(.:format)"                ,:action=>'new'    ,:controller=>'singular' }.freeze
  @@s_classic_show   = { :name=>          'singular' ,:verb=>'GET'   ,:path=>"/singular(.:format)"                    ,:action=>'show'   ,:controller=>'singular' }.freeze
  @@s_classic_create = { :name=>                  '' ,:verb=>'POST'  ,:path=>"/singular(.:format)"                    ,:action=>'create' ,:controller=>'singular' }.freeze
  @@s_classic_update = { :name=>                  '' ,:verb=>'PUT'   ,:path=>"/singular(.:format)"                    ,:action=>'update' ,:controller=>'singular' }.freeze
  @@s_classic_destroy= { :name=>                  '' ,:verb=>'DELETE',:path=>"/singular(.:format)"                    ,:action=>'destroy',:controller=>'singular' }.freeze
  @@s_classic_edit   = { :name=>     'edit_singular' ,:verb=>'GET'   ,:path=>"/singular/edit(.:format)"               ,:action=>'edit'   ,:controller=>'singular' }.freeze
  @@s_restful_new    = { :name=>'singular_new'       ,:verb=>'GET'   ,:path=>"/singular/new(.:format)"                ,:action=>'new'    ,:controller=>'singular' }.freeze
  @@s_restful_show   = { :name=>'singular_root'      ,:verb=>'GET'   ,:path=>"/singular(.:format)"                    ,:action=>'show'   ,:controller=>'singular' }.freeze
  @@s_restful_create = @@s_classic_create
  @@s_restful_update = @@s_classic_update
  @@s_restful_destroy= @@s_classic_destroy
  @@s_restful_edit   = { :name=>'singular_edit'      ,:verb=>'GET'   ,:path=>"/singular/edit(.:format)"               ,:action=>'edit'   ,:controller=>'singular' }.freeze
  @@s_pretty_new     = @@s_restful_new
  @@s_pretty_show    = { :name=>'singular_show'      ,:verb=>'GET'   ,:path=>"/singular/show(.:format)"               ,:action=>'show'   ,:controller=>'singular' }.freeze
  @@s_pretty_create  = { :name=>'singular_create'    ,:verb=>'POST'  ,:path=>"/singular/create(.:format)"             ,:action=>'create' ,:controller=>'singular' }.freeze
  @@s_pretty_update  = { :name=>'singular_update'    ,:verb=>'PUT'   ,:path=>"/singular/update(.:format)"             ,:action=>'update' ,:controller=>'singular' }.freeze
  @@s_pretty_destroy = { :name=>'singular_destroy'   ,:verb=>'DELETE',:path=>"/singular/destroy(.:format)"            ,:action=>'destroy',:controller=>'singular' }.freeze
  @@s_pretty_edit    = @@s_restful_edit

  # These class methods return a hash which describes an individual route.
  def self.classic_index()     @@classic_index     ; end
  def self.classic_create()    @@classic_create    ; end
  def self.classic_new()       @@classic_new       ; end
  def self.classic_show()      @@classic_show      ; end
  def self.classic_update()    @@classic_update    ; end
  def self.classic_destroy()   @@classic_destroy   ; end
  def self.classic_edit()      @@classic_edit      ; end
  def self.restful_index()     @@restful_index     ; end
  def self.restful_create()    @@restful_create    ; end
  def self.restful_new()       @@restful_new       ; end
  def self.restful_show()      @@restful_show      ; end
  def self.restful_update()    @@restful_update    ; end
  def self.restful_destroy()   @@restful_destroy   ; end
  def self.restful_edit()      @@restful_edit      ; end
  def self.pretty_index()      @@pretty_index      ; end
  def self.pretty_new()        @@pretty_new        ; end
  def self.pretty_edit()       @@pretty_edit       ; end
  def self.pretty_create()     @@pretty_create     ; end
  def self.pretty_show()       @@pretty_show       ; end
  def self.pretty_update()     @@pretty_update     ; end
  def self.pretty_destroy()    @@pretty_destroy    ; end
  def self.s_classic_new()     @@s_classic_new     ; end
  def self.s_classic_show()    @@s_classic_show    ; end
  def self.s_classic_create()  @@s_classic_create  ; end
  def self.s_classic_update()  @@s_classic_update  ; end
  def self.s_classic_destroy() @@s_classic_destroy ; end
  def self.s_classic_edit()    @@s_classic_edit    ; end
  def self.s_restful_new()     @@s_restful_new     ; end
  def self.s_restful_show()    @@s_restful_show    ; end
  def self.s_restful_create()  @@s_restful_create  ; end
  def self.s_restful_update()  @@s_restful_update  ; end
  def self.s_restful_destroy() @@s_restful_destroy ; end
  def self.s_restful_edit()    @@s_restful_edit    ; end
  def self.s_pretty_new()      @@s_pretty_new      ; end
  def self.s_pretty_show()     @@s_pretty_show     ; end
  def self.s_pretty_create()   @@s_pretty_create   ; end
  def self.s_pretty_update()   @@s_pretty_update   ; end
  def self.s_pretty_destroy()  @@s_pretty_destroy  ; end
  def self.s_pretty_edit()     @@s_pretty_edit     ; end

  # Build some useful arrays which model various sets of route descriptors.
  # If these tests are failing due to re-arranged sequence, these arrays may be safely
  # re-sequenced to match any generated order, provided you're convinced it doesn't break anything
  # in the routing priorities. That is, make these arrays match the generation sequence, but be
  # sure the upper-priority routes can't short-circuit the lower ones.
  @@classic_route_ar = [ @@classic_index, @@classic_create, @@classic_new, @@classic_show, @@classic_update, @@classic_destroy, @@classic_edit ].freeze
  @@s_classic_route_ar = [ @@s_classic_new, @@s_classic_show, @@s_classic_create, @@s_classic_update, @@s_classic_destroy, @@s_classic_edit ].freeze
  @@restful_route_ar = [ @@restful_index, @@restful_create, @@restful_new, @@restful_show, @@restful_update, @@restful_destroy, @@restful_edit ].freeze
  @@s_restful_route_ar = [ @@s_restful_new, @@s_restful_show, @@s_restful_create, @@s_restful_update, @@s_restful_destroy, @@s_restful_edit ].freeze
  @@pretty_route_ar = [ @@pretty_index, @@pretty_new, @@pretty_create, @@pretty_show, @@restful_edit, @@pretty_update, @@pretty_destroy ].freeze
  @@s_pretty_route_ar = [ @@s_pretty_new, @@s_pretty_create, @@s_pretty_show, @@s_pretty_edit, @@s_pretty_update, @@s_pretty_destroy ].freeze
  @@default_route_ar = [ @@restful_index, @@restful_create, @@pretty_index, @@restful_new, @@restful_show, @@restful_update, @@restful_destroy, @@restful_edit ].freeze
  @@s_default_route_ar = [ @@s_restful_new, @@s_restful_show, @@s_restful_create, @@s_restful_update, @@s_restful_destroy, @@s_restful_edit ].freeze
  @@pretty_plus_restful_route_ar = [ @@restful_index, @@restful_create, @@pretty_index, @@restful_new, @@pretty_create,
        @@restful_show, @@restful_update, @@restful_destroy, @@pretty_show, @@pretty_edit, @@pretty_update, @@pretty_destroy ].freeze
  @@s_pretty_plus_restful_route_ar = [ @@s_restful_new, @@s_pretty_create, @@s_restful_show, @@s_restful_create,
        @@s_restful_update, @@s_restful_destroy, @@s_pretty_show, @@s_pretty_edit, @@s_pretty_update, @@s_pretty_destroy ].freeze
  @@classic_plus_restful_route_ar = (@@classic_route_ar | @@restful_route_ar).freeze
  @@s_classic_plus_restful_route_ar = (@@s_classic_route_ar | @@s_restful_route_ar).freeze
  @@classic_plus_pretty_route_ar = (@@classic_route_ar | @@pretty_route_ar).freeze
  @@s_classic_plus_pretty_route_ar = (@@s_classic_route_ar | @@s_pretty_route_ar).freeze
  @@classic_plus_default_route_ar = (@@classic_route_ar | @@default_route_ar).freeze
  @@s_classic_plus_default_route_ar = (@@s_classic_route_ar | @@s_default_route_ar).freeze
  @@all_route_ar = (@@classic_route_ar | @@pretty_plus_restful_route_ar).freeze
  @@s_all_route_ar = (@@s_classic_route_ar | @@s_pretty_plus_restful_route_ar).freeze

  # These return an array of route descriptor hashes, sequenced by precidence.
  def self.classic_route_ar()                @@classic_route_ar               ; end
  def self.s_classic_route_ar()              @@s_classic_route_ar             ; end
  def self.restful_route_ar()                @@restful_route_ar               ; end
  def self.s_restful_route_ar()              @@s_restful_route_ar             ; end
  def self.pretty_route_ar()                 @@pretty_route_ar                ; end
  def self.s_pretty_route_ar()               @@s_pretty_route_ar              ; end
  def self.default_route_ar()                @@default_route_ar               ; end
  def self.s_default_route_ar()              @@s_default_route_ar             ; end
  def self.pretty_plus_restful_route_ar()    @@pretty_plus_restful_route_ar   ; end
  def self.s_pretty_plus_restful_route_ar()  @@s_pretty_plus_restful_route_ar ; end
  def self.classic_plus_pretty_route_ar()    @@classic_plus_pretty_route_ar   ; end
  def self.s_classic_plus_pretty_route_ar()  @@s_classic_plus_pretty_route_ar ; end
  def self.classic_plus_restful_route_ar()   @@classic_plus_restful_route_ar  ; end
  def self.s_classic_plus_restful_route_ar() @@s_classic_plus_restful_route_ar; end
  def self.all_route_ar()                    @@all_route_ar                   ; end
  def self.s_all_route_ar()                  @@s_all_route_ar                 ; end
  def self.classic_plus_default_route_ar()   @@classic_plus_default_route_ar  ; end
  def self.s_classic_plus_default_route_ar() @@s_classic_plus_default_route_ar; end

  # These return a few more useful arrays.
  def self.restful_c_u_d_ar()
    [ RT.restful_create, RT.restful_update, RT.restful_destroy ] ; end
  def self.s_restful_c_u_d_ar()
    [ RT.s_restful_create, RT.s_restful_update, RT.s_restful_destroy ] ; end

  end # class

# Return an array of all routes in routeset parameter, sorted by match
# priority. Each element of the array represents one route as a hash.
def route_descriptor_ar(routeset)
  routeset.routes.collect do |route|
    name = routeset.named_routes.routes.index(route).to_s
    verb = route.conditions[:method].to_s.upcase
    path = route.segments.inject("") { |str,s| str << s.to_s }
    path.chop! if path.length > 1
    { :name=>name, :verb=>verb, :path=>path }.merge(route.requirements)
  end ; end
# Return a route_descriptor_ar of all live-running routes.
def live_route_ar
  route_descriptor_ar(ActionController::Routing::Routes)
  end
# Return a route_descriptor_ar of all routes generated by an actual
# call to ActionController::Routing::RouteSet#resources(...)
def genuine_rails_resources_route_ar(*args)
  temp_routes = ActionController::Routing::RouteSet.new
  temp_routes.draw {|map| map.resources(*args) }
  route_descriptor_ar(temp_routes)
  end

def have_distinct_routes(*args) HaveDistinctRoutes.new(*args) ; end
class HaveDistinctRoutes
  def initialize() ; @msg_ar = [] ; end
  def matches?(route_set)
    siz = route_set.size
    for i1 in 0...siz ; r1 = route_set[i1]
      for i2 in (i1+1)...siz ; r2 = route_set[i2]
        ( @msg_ar << "Duplicate route: #{r1.to_s}"
          ) if r1.segments.to_s==r2.segments.to_s && r1.conditions==r2.conditions && r1.requirements==r2.requirements
      end ; end
      @msg_ar.empty?
    end
  def failure_message() ; @msg_ar.join("\n") ; end
  end

def mismatch_i_ar(exp_route_ar, got_route_ar, offset=0)
  rval = []
  exp_route_ar.each_with_index do |r,i|
    got_route_ar[i] ||= nil # pad got_route_ar to same length, to show (missing route) in messages.
    rval << i+offset unless r.nil? && !got_route_ar[i].blank? or r==got_route_ar[i]
    end
  exp_route_ar.size.upto(got_route_ar.size-1) {|i| rval << i }
  rval ; end
def name_wid_path_wid(*r_ar_ar) # Return widest widths for :name and :path Strings.
  name_wid = 10 ; path_wid = 16 ; [r_ar_ar].each {|r_ar| r_ar.each {|a| a.each {|r| next unless r.is_a?(Hash)
    name_wid = name_wid.not_below((r[:name]||'').length) ; path_wid = path_wid.not_below((r[:path]||'').length) } } }
  [name_wid, path_wid] ; end
def printable_routeset_ar(exp_or_got_sym, routeset, flag_ar=[], name_wid=0, path_wid=0) show_i = flag_ar!=false ; flag_ar ||= []
  return ['  (no routes)'] if routeset.empty?
  nil_msg = exp_or_got_sym == :exp ? '(any route)' : ( exp_or_got_sym == :got ? '(missing route)' : '(nil)' )
  routeset = routeset.collect {|r| r.nil? ? {:path=>nil_msg} : r.dup }
  name_ar = routeset.collect {|r| r.delete(:name) || '' }
  path_ar = routeset.collect {|r| r.delete(:path) || '' }
  verb_ar = routeset.collect {|r| "#{r.delete(:verb)||''}      "[0..5] }
  extra_ar= routeset.collect {|r| r.empty? ? '' : r.inspect }
  i_wid = (routeset.size+9).to_s.length # If this list is >100 lines it'll be off by 1 column against a juxtaposed partner set of <100 lines.
  rval = []
  routeset.size.times {|i| rval << "#{flag_ar.include?(i) ? '*' : ' '}#{(show_i ? i.to_s : '').rjust(i_wid)} #{(name_ar[i]).rjust(name_wid)} #{verb_ar[i]} #{(path_ar[i]).ljust(path_wid)} #{extra_ar[i]}" }
  rval ; end

def be_exact_routes(*args) BeExactRoutes.new(*args) ; end
  # Passes if the routes given exactly match the routes registered to ActiveController. Must
  # be the same number of routes, in the same order, with identical attributes, except that
  # if an expected route position contains nil, it matches any route in that position.
class BeExactRoutes
  def initialize() ; @msg_ar = [] ; end
  def matches?(exp_route_ar)
    got_route_ar = live_route_ar
    return true if exp_route_ar==got_route_ar
    bad_ar = mismatch_i_ar(exp_route_ar, got_route_ar)
    return true if bad_ar.empty?
    name_wid, path_wid = name_wid_path_wid(exp_route_ar, got_route_ar)
    @msg_ar << "Expected these routes, and no others, in this order:"
    @msg_ar += printable_routeset_ar(:exp, exp_route_ar, bad_ar, name_wid, path_wid)
    @msg_ar << "Complete list of the routes actually generated:"
    @msg_ar += printable_routeset_ar(:got, got_route_ar, bad_ar, name_wid, path_wid)
    false
    end
  def failure_message() @msg_ar.join("\n") ; end
  end

def be_consecutive_routes(*args) BeConsecutiveRoutes.new(*args) ; end
  # Passes if the routes given occur as a consecutive run in ActiveController. All
  # expected routes must be listed in the same order, with identical attributes,
  # except that if a given route is nil, it matches any route in that position.
class BeConsecutiveRoutes
  def initialize() ; @msg_ar = [] ; end
  def matches?(exp_route_ar)
    raise "Empty call to BeConsecutiveRoutes" if exp_route_ar.empty?
    got_big_route_ar = live_route_ar
    r0 = exp_route_ar.first
    base_i = got_big_route_ar.index( got_big_route_ar.find {|r| r==r0 } || got_big_route_ar.find {|r| r[:name]==r0[:name] } ||
      got_big_route_ar.find {|r| r[:path]==r0[:path] && r[:verb]==r0[:verb] } ||
      got_big_route_ar.find {|r| r[:action]==r0[:action] && r[:controller]==r0[:controller] } ) || 0
    got_little_route_ar = got_big_route_ar[base_i...(base_i+exp_route_ar.size)]
    return true if exp_route_ar==got_little_route_ar
    bad_ar = mismatch_i_ar(exp_route_ar, got_little_route_ar, base_i)
    return true if bad_ar.empty?
    name_wid, path_wid = name_wid_path_wid(exp_route_ar, got_big_route_ar)
    @msg_ar << "Expected these routes to occur consecutively:"
    @msg_ar += printable_routeset_ar(:exp, exp_route_ar, false, name_wid, path_wid)
    @msg_ar << "Complete list of the routes actually generated:"
    @msg_ar += printable_routeset_ar(:got, got_big_route_ar, bad_ar, name_wid, path_wid)
    false
    end
  def failure_message() @msg_ar.join("\n") ; end
  end

def be_assorted_routes(*args) BeAssortedRoutes.new(*args) ; end
  # Passes if all the expected routes occur anywhere in ActiveController.
class BeAssortedRoutes
  def initialize() ; @msg_ar = [] ; end
  def matches?(exp_route_ar)
    got_route_ar = live_route_ar
    raise "Empty call to BeAssortedRoutes" if exp_route_ar.empty?
    name_wid, path_wid = name_wid_path_wid(exp_route_ar, got_route_ar)
    bad_ar = []
    exp_route_ar.each_with_index {|exp_descr,i| bad_ar << i unless got_route_ar.include?(exp_descr) }
    return true if bad_ar.empty?
    @msg_ar << "Routes expected anywhere in the collection (*not found):"
    @msg_ar += printable_routeset_ar(:exp, exp_route_ar, bad_ar, name_wid, path_wid)
    @msg_ar << "Complete list of the routes actually generated:"
    @msg_ar += printable_routeset_ar(:got, got_route_ar, [], name_wid, path_wid)
    false
    end
  def failure_message() @msg_ar.join("\n") ; end
  end

# runs should_have_collec_refer_classics and should_have_collec_named_classics, without passing a block.
def should_have_collec_classics(singular, plural, options={})
  should_have_collec_refer_classics singular, plural, options
  should_have_collec_named_classics singular, plural, options
  end

def load_classic_collec_vars!(singular, plural, options)
  @opts = adjusted_opts!(singular, options)
  load_new_and_edit_actions!
  @path             = "#{@opts[:as] || plural}"
  @collec_path      = "/#{@opts[:path_prefix]}#{@path}"
  @shallow_path     = "/#{@opts[:path_prefix] unless @opts[:shallow]}#{@path}"
  @member_path      = "#{@shallow_path}/1"
  @new_path         = "#{@collec_path}/#{@new_action}"
  @edit_member_path = "#{@member_path}#{@a_sep}#{@edit_action}"
  end
def load_classic_singleton_vars!(singular, options)
  @opts = adjusted_opts!(singular, options)
  load_new_and_edit_actions!
  @full_path   = "/#{@opts[:path_prefix]}#{@opts[:as] || singular}"
  @new_path    = "#{@full_path}/#{@new_action}"
  @edit_path   = "#{@full_path}#{@a_sep}#{@edit_action}"
  @edit_path_f = "#{@edit_path}.xml"
  end
# (=>Hash) Adds/modifies options[:options] and options[:shallow_options] for use in the collection should()'s.
def adjusted_opts!(singular, options)
  c = options[:controller] || singular.to_s
  (options[:options]||={}).merge!(:controller=>c)
  options[:shallow_options] = options[:shallow] ? (options[:shallow_options]||{}).merge(:controller=>c) : options[:options]
  options
  end
def load_new_and_edit_actions!
  @new_action    = ActionController::Base.resources_path_names[:new]  || "new"
  @edit_action   = ActionController::Base.resources_path_names[:edit] || "edit"
  if @opts[:path_names]
    @new_action  = @opts[:path_names][:new]  || @new_action
    @edit_action = @opts[:path_names][:edit] || @edit_action ; end
  end

def should_have_collec_refer_classics(singular, plural, options={})  # assert_restful_routes_for
  load_classic_collec_vars!(singular, plural, options)
  with_options(@opts[:options]) do |controller|
    controller.should_route @collec_path              ,:action=>'index'
    controller.should_route @new_path                 ,:action=>'new'
    controller.should_route "#{@collec_path}.xml"     ,:action=>'index'          ,:format=>'xml'
    controller.should_route "#{@new_path}.xml"        ,:action=>'new'            ,:format=>'xml'
    end
  with_options(@opts[:shallow_options]) do |controller|
    controller.should_route @member_path              ,:action=>'show' ,:id=>'1'
    controller.should_route @edit_member_path         ,:action=>'edit' ,:id=>'1'
    controller.should_route "#{@member_path}.xml"     ,:action=>'show' ,:id=>'1' ,:format=>'xml'
    controller.should_route "#{@edit_member_path}.xml",:action=>'edit' ,:id=>'1' ,:format=>'xml'
    end
  should_recognize(@opts[:options        ].merge(:action=>'index'                            ) ,:path=>@collec_path               ,:method=>:get)
  should_recognize(@opts[:options        ].merge(:action=>'new'                              ) ,:path=>@new_path                  ,:method=>:get)
  should_recognize(@opts[:options        ].merge(:action=>'create'                           ) ,:path=>@collec_path               ,:method=>:post)
  should_recognize(@opts[:shallow_options].merge(:action=>'show'    ,:id=>'1'                ) ,:path=>@member_path               ,:method=>:get)
  should_recognize(@opts[:shallow_options].merge(:action=>'edit'    ,:id=>'1'                ) ,:path=>@edit_member_path          ,:method=>:get)
  should_recognize(@opts[:shallow_options].merge(:action=>'update'  ,:id=>'1'                ) ,:path=>@member_path               ,:method=>:put)
  should_recognize(@opts[:shallow_options].merge(:action=>'destroy' ,:id=>'1'                ) ,:path=>@member_path               ,:method=>:delete)
  should_recognize(@opts[:options        ].merge(:action=>'index'             ,:format=>'xml') ,:path=>"#{@collec_path}.xml"      ,:method=>:get)
  should_recognize(@opts[:options        ].merge(:action=>'new'               ,:format=>'xml') ,:path=>"#{@new_path}.xml"         ,:method=>:get)
  should_recognize(@opts[:options        ].merge(:action=>'create'            ,:format=>'xml') ,:path=>"#{@collec_path}.xml"      ,:method=>:post)
  should_recognize(@opts[:shallow_options].merge(:action=>'show'    ,:id=>'1' ,:format=>'xml') ,:path=>"#{@member_path}.xml"      ,:method=>:get)
  should_recognize(@opts[:shallow_options].merge(:action=>'edit'    ,:id=>'1' ,:format=>'xml') ,:path=>"#{@edit_member_path}.xml" ,:method=>:get)
  should_recognize(@opts[:shallow_options].merge(:action=>'update'  ,:id=>'1' ,:format=>'xml') ,:path=>"#{@member_path}.xml"      ,:method=>:put)
  should_recognize(@opts[:shallow_options].merge(:action=>'destroy' ,:id=>'1' ,:format=>'xml') ,:path=>"#{@member_path}.xml"      ,:method=>:delete)
  yield @opts[:options] if block_given?
  end

# test named routes like foo_path and foos_path map to the correct options.
def should_have_collec_named_classics(singular, plural, options={}) # assert_named_restful_routes_for
  load_classic_collec_vars!(singular, plural, options)
  @controller = "#{@opts[:options][:controller].camelize}Controller".constantize.new
  # @request    = ActionController::TestRequest.new
  # @response   = ActionController::TestResponse.new
  get :index, options[:options]
  @opts[:options].delete :action
  name_prefix = @opts[:name_prefix]
  shallow_prefix = "#{@opts[:name_prefix] unless @opts[:shallow]}"
  should_be_named_route "#{@collec_path}"         ,          "#{name_prefix}#{plural}" ,@opts[:options        ]
  should_be_named_route "#{@collec_path}.xml"     ,          "#{name_prefix}#{plural}" ,@opts[:options        ].merge(         :format=>'xml')
  should_be_named_route "#{@new_path}"            ,    "new_#{name_prefix}#{singular}" ,@opts[:options        ]
  should_be_named_route "#{@new_path}.xml"        ,    "new_#{name_prefix}#{singular}" ,@opts[:options        ].merge(         :format=>'xml')
  should_be_named_route "#{@shallow_path}/1"      ,     "#{shallow_prefix}#{singular}" ,@opts[:shallow_options].merge(:id=>'1'               )
  should_be_named_route "#{@shallow_path}/1.xml"  ,     "#{shallow_prefix}#{singular}" ,@opts[:shallow_options].merge(:id=>'1',:format=>'xml')
  should_be_named_route "#{@edit_member_path}"    ,"edit_#{shallow_prefix}#{singular}" ,@opts[:shallow_options].merge(:id=>'1'               )
  should_be_named_route "#{@edit_member_path}.xml","edit_#{shallow_prefix}#{singular}" ,@opts[:shallow_options].merge(:id=>'1',:format=>'xml')
  yield options[:options] if block_given?
  end

def should_have_singleton_classics(singular, options={})
  should_have_singleton_refer_classics singular, options
  should_have_singleton_named_classics singular, options
  end

def should_have_singleton_refer_classics(singular, options={})
  # options[:options] ||= {}
  # options[:options][:controller] = options[:controller] || singular.to_s
  load_classic_singleton_vars!(singular, options)
  with_options @opts[:options] do |controller|
    controller.should_route @full_path          ,:action=>'show'
    controller.should_route @new_path           ,:action=>'new'
    controller.should_route @edit_path          ,:action=>'edit'
    controller.should_route "#{@full_path}.xml" ,:action=>'show' ,:format=>'xml'
    controller.should_route "#{@new_path}.xml"  ,:action=>'new'  ,:format=>'xml'
    controller.should_route @edit_path_f        ,:action=>'edit' ,:format=>'xml'
    end
  should_recognize(@opts[:options].merge(:action=>'show'                   ) ,:path=>@full_path          ,:method=>:get)
  should_recognize(@opts[:options].merge(:action=>'new'                    ) ,:path=>@new_path           ,:method=>:get)
  should_recognize(@opts[:options].merge(:action=>'edit'                   ) ,:path=>@edit_path          ,:method=>:get)
  should_recognize(@opts[:options].merge(:action=>'create'                 ) ,:path=>@full_path          ,:method=>:post)
  should_recognize(@opts[:options].merge(:action=>'update'                 ) ,:path=>@full_path          ,:method=>:put)
  should_recognize(@opts[:options].merge(:action=>'destroy'                ) ,:path=>@full_path          ,:method=>:delete)
  should_recognize(@opts[:options].merge(:action=>'show'    ,:format=>'xml') ,:path=>"#{@full_path}.xml" ,:method=>:get)
  should_recognize(@opts[:options].merge(:action=>'new'     ,:format=>'xml') ,:path=>"#{@new_path}.xml"  ,:method=>:get)
  should_recognize(@opts[:options].merge(:action=>'edit'    ,:format=>'xml') ,:path=>@edit_path_f        ,:method=>:get)
  should_recognize(@opts[:options].merge(:action=>'create'  ,:format=>'xml') ,:path=>"#{@full_path}.xml" ,:method=>:post)
  should_recognize(@opts[:options].merge(:action=>'update'  ,:format=>'xml') ,:path=>"#{@full_path}.xml" ,:method=>:put)
  should_recognize(@opts[:options].merge(:action=>'destroy' ,:format=>'xml') ,:path=>"#{@full_path}.xml" ,:method=>:delete)
  yield @opts[:options] if block_given?
  end

def should_have_singleton_named_classics(singular, options={})
  load_classic_singleton_vars!(singular, options)
  @controller = "#{@opts[:options][:controller].camelize}Controller".constantize.new
  # @request    = ActionController::TestRequest.new
  # @response   = ActionController::TestResponse.new
  get :show, @opts[:options]
  @opts[:options].delete :action
  name_prefix = options[:name_prefix]
  should_be_named_route "#{@full_path}"     ,      "#{name_prefix}#{singular}" ,@opts[:options]
  should_be_named_route "#{@full_path}.xml" ,      "#{name_prefix}#{singular}" ,@opts[:options].merge(:format=>'xml')
  should_be_named_route "#{@new_path}"      ,  "new_#{name_prefix}#{singular}" ,@opts[:options]
  should_be_named_route "#{@new_path}.xml"  ,  "new_#{name_prefix}#{singular}" ,@opts[:options].merge(:format=>'xml')
  should_be_named_route "#{@edit_path}"     , "edit_#{name_prefix}#{singular}" ,@opts[:options]
  should_be_named_route "#{@edit_path}.xml" , "edit_#{name_prefix}#{singular}" ,@opts[:options].merge(:format=>'xml')
  end

def should_be_named_route(exp_path, route_name, options={})
# puts "\n#{@controller.class}\n#{exp_path.inspect}\n#{route_name.inspect}\n#{options.inspect}\n\n"
  raise "@controller must be set before calling should_be_named_route()" unless @controller
  path_method = "#{route_name}_path".to_sym
  got_path = @controller.send(path_method, options) rescue "#{$!.class.name} for #{path_method}"
  got_path.should == exp_path
  end

def should_recognize(exp_options, path, extras={}, message=nil)
  path.is_a?(Hash) ? ( verb, path = path[:method], path[:path] ) : verb = nil
  request = recognize_request(path, verb)
  exp_options = exp_options.clone
  extras.each_key {|key| exp_options.delete key } unless extras.nil?
  exp_options.stringify_keys!
  request.path_parameters.should == exp_options
  end

def should_generate(exp_path, options, defaults={}, extras={}, message=nil)
  exp_path = "/#{exp_path}" unless exp_path.first == '/'
  got_path, extra_keys = ActionController::Routing::Routes.generate_extras(options, defaults)
  found_extras = options.reject {|k,v| ! extra_keys.include? k}
  found_extras.should == extras
  got_path.should == exp_path
  end

def should_route(path, options, defaults={}, extras={}, message=nil)
  should_recognize(options, path, extras, message)
  controller, default_controller = options[:controller], defaults[:controller]
  options[:controller] = "/#{controller}" if controller && controller.include?(?/) && default_controller && default_controller.include?(?/)
  should_generate(path.is_a?(Hash) ? path[:path] : path, options, defaults, extras, message)
  end

# Recognizes the route for a given path.
def recognize_request(path, verb=nil)
  path = "/#{path}" unless path.first == '/'
  # Assume given controller
  request = ActionController::TestRequest.new({})
  request.env["REQUEST_METHOD"] = verb.to_s.upcase if verb
  request.path = path
  ActionController::Routing::Routes.recognize(request)
  request
  end
